Vue.js란 무엇인가?

    Vue(/vjuː/ 로 발음, view 와 발음이 같습니다.)는 
    사용자 인터페이스를 만들기 위한 진보적인 프레임워크 입니다. 
    다른 단일형 프레임워크와 달리 Vue는 점진적으로 채택할 수 있도록 
    설계하였습니다. 핵심 라이브러리는 뷰 레이어만 초점을 맞추어 
    다른 라이브러리나 기존 프로젝트와의 통합이 매우 쉽습니다. 
    그리고 Vue는 현대적 도구 및 지원하는 라이브러리와 함께 사용한다면 
    정교한 단일 페이지 응용프로그램을 완벽하게 지원할 수 있습니다.

호환성 정보

    Vue는 ECMAScript 5 기능을 사용하기 때문에 
    IE8 이하 버전을 지원하지 않습니다. 
    하지만 모든 ECMAScript 5 호환 브라우저를 지원합니다.

Vue Devtools

    Vue를 사용할 때, 브라우저에 Vue Devtools를 설치하세요. 
    Vue 앱을 보다 사용자 친화적으로 검사하고 디버그할 수 있습니다.

직접 <script>에 추가

    다운로드 받아 script 태그에 추가하기만 하면 됩니다.
    Vue는 전역 변수로 등록됩니다.

    (개발 중에는 최소화 버젼을 사용하지 마십시오. 일반적인 실수에
    대한 모든 훌륭한 경고를 놓치게됩니다!)    
    
    *개발중에는 개발용 버젼을 사용하자(디버그 제공)
    배포용 버젼은 경고가 제거된다.(최소화 버젼)

NPM

    Vue로 대규모 응용 프로그램을 빌드할 때 NPM을 권장합니다.
    Webpack 또는 Browserify와 같은 모듈 번들러와 잘 작동합니다.
    Vue는 싱글 파일 컴포넌트를 만들기 위한 도구도 제공합니다.

        npm install Vue

CLI

    Vue.js는 단일 페이지 응용 프로그램을 빠르게 스캐폴딩하기 위한 공식
    CLI를 제공합니다. 현대적인 프론트엔드 워크플로우를 위해 잘 구성된
    빌드 설정을 제공합니다. 핫 리로드, lint-on-save 및 프로덕션 준비가 된
    빌드로 시작하고 실행하는데 몇 분 밖에 걸리지 않습니다.

        npm install --global vue-cli

        vue init webpack my-project

        cd my-project

        npm install

        npm run dev

기타 - package.json 생성

    package.json을 생성하려면 프로젝트 루트에서 npm init
    명령어를 실행한다.

    npm init 명령어를 사용하면 프로젝트에 대한 여러 가지 정보를 
    입력하도록 요구받는다. 

기타 - 나이트왓치

    나이트왓치는 노드 기반의 E2E 테스트 프레임워크다. 
    (배보다 배꼽이 더 큰 경우가 발생할 수 있음.)
    충분한 전문성과 기회비용을 필요로 한다.

각 다른 빌드간 차이점

            	    UMD           	CommonJS	            ES Module

Full    	        vue.js	        vue.common.js	        vue.esm.js

Runtime-only	    vue.runtime.js  vue.runtime.common.js	vue.runtime.esm.js

Full (production)	vue.min.js	        -	                    -

Runtime-only        vue.runtime.min.js	-	                    -
(production)	

    AMD(Asynchronous Module Definition)

        비동기 모듈 정의(AMD) 포맷은 브라우저에서
        사용되고 define 함수를 사용해서 모듈을 정의한다.

    UMD(Universal Module Definition)

        만능 모듈 정의(UMD)로, 브라우저와 Node.js에서
        둘 다 사용될 수 있다.

    CommonJS 포맷

        Node.js에서 사용되고 require와 module.exports
        를 사용해서 의존성과 모듈을 정의한다.

    ES6 모듈 포맷
    
        ES6에서 자바스크립트는 내장된 모듈 포맷도 지원한다.

        모듈의 공개 API로 내보내기 위해 export 토큰을 사용한다.
        import는 모듈이 내보내는 부분을 가져온다.
        as를 사용하여 가져오는 모듈에 별명을 줄 수도 있다.
        전체 모듈을 한 번에 로드할 수도 있다. (* 사용)
        default export도 지원한다. (사용하면 모듈을 가져올 때
        괄호 {}를 사용하지 않아도 되며, 단일 값을 내보낼 때 사용한다.)
        함수 뿐만 아니라 어떤 것이든 내보낼 수 있다.
        불행하게도 내장된 모듈 포맷은 아직 모든 브라우저에서 지원되지
        않는다.
        그래서 우리는 이미 ES6 모듈 포맷을 사용할 수 있지만,
        브라우저에서 코드를 실행하기 전에 Babel과 같은
        변환기를 사용해 ES5 모듈 포맷(AMD 또는 CommonJS)로 코드
        변환이 필요하다.

    모듈 로더

        모듈 로더는 주요 모듈 포맷으로 작성된 모듈을 해석하고 로드한다.
        모듈 로더는 런타임에 실행된다.

        - 브라우저에서 모듈 로더를 로드한다.
        - 모듈 로더에게 어떤 메인 애플리케이션 파일을 로드할 것인지 알려준다.
        - 모듈 로더는 메인 애플리케이션 파일을 다운로드하고 해석한다.
        - 필요한 경우 모듈 로더가 파일을 다운로드한다.

        브라우저 개발자 콘솔에서 네트워크 탭을 열면, 모듈 로더에 의해
        많은 파일들이 로드된 것을 볼 수 있다.

        인기 있는 모듈 로더로는 RequireJs, SystemJS 가 있다.

    모듈 번들러

        모듈 번들러는 모듈 로더를 대체한다.

        모듈 로더와 반대로 모듈 번들러는 빌드 타임에 실행된다.

        - 빌드 타임에 번들 파일을 생성하기 위해 모듈 번들러를 실행한다.
          (예:bundle.js)
        - 브라우저에서 번들 파일을 로드한다.

        브라우저 개발자 콘솔에서 네트워크 탭을 열면, 모듈 로더에 의해
        1개 파일만 로드된 것을 볼 수 있다.
        브라우저에서 모듈 로더를 필요로 하지 않는다.
        모든 코드는 번들 안에 포함되어 있다.
        
        인기 있는 모듈 번들에는 다음과 같은 것들이 있다.

        - Browserify : CommonJS 모듈을 위한 번들러
        - Webpack : AMD, CommonJS, ES6 모듈을 위한 번들러

    요약

        모던 자바스크립트 개발 환경에서 툴링을 잘 이해하기 위해서는
        모듈, 모듈 포맷, 모듈 로더와 모듈 번들러 사이의 차이를
        이해하는 것이 중요하다.

        모듈은 구현 세부 사항을 캡슐화하고 공개 API를 노출해
        다른 코드에서 쉽게 로드하고 사용할 수 있도록
        재사용 가능한 코드 조각이다.

        모듈 포맷은 모듈을 정의하기 위해 사용하는 문법이다.
        AMD, CommonJS, UMD, System.register 와 같은
        여러 모듈 포맷이 과거에 등장했으며, ES6부터 내장된 모듈
        포맷을 사용할 수 있다.

        모듈 로더는 주요 모듈 포맷으로 작성된 모듈을 런타임 때
        로드하고 해석한다. RequireJS와 SystemJS가 있다.

        모듈 번들러는 모듈 로더를 대체하고 빌드 타임에 모든 코드의
        번들을 생성한다. Browserify와 Webpack이 있다.

        참조 : https://github.com/codepink/codepink.github.com/wiki/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88,-%EB%AA%A8%EB%93%88-%ED%8F%AC%EB%A7%B7,-%EB%AA%A8%EB%93%88-%EB%A1%9C%EB%8D%94%EC%99%80-%EB%AA%A8%EB%93%88-%EB%B2%88%EB%93%A4%EB%9F%AC%EC%97%90-%EB%8C%80%ED%95%9C-10%EB%B6%84-%EC%9E%85%EB%AC%B8%EC%84%

자바스크립트 모듈 사용의 배경

    자바스크립트는 파이썬, 루비, 다른 스크립트 언어 계열과 차이점이 존재한다.
    바로 모듈 사용의 표준이 존재하지 않다는 것이다. (ECMA5 기준)

    Node.js를 사용하고 있는 개발자들은 module.exports를 통해 
    모듈을 정의하고 require() 함수를 통해 정의한 모듈을 불러와 
    사용하고 있다. 이러한 방식을 CommonJS라고 부른다.

    Node.js 모듈 형태를 보면 다른언어에 비해 모듈제공이 조금 차이가 있다.
    module.exports와 exports 두개를 사용하는데
    이런 제공방식은 혼동을 초래하기도 한다.
    문제는 프론트엔드에서는 이런 모듈 제공방식이 없었다는 것이다!

    프론트엔드에서 사용하는 자바스크립트는 DOM 오브젝트를 사용하고 있다.
    전역 오브젝트인 window를 사용하면 다른 자바스크립트 파일에 
    리소스를 전달 할 수 있다.

    하지만 이것도 사용하는 HTML에서 불러오는 모듈 파일을 먼저 로드해야
    문제가 없이 작동된다.

    즉 대상 모듈이 존재 할 수도, 존재하지 않을 수도 있는 상태가 벌어진다. 
    (으아아악!)

    하지만 프론트엔드에서 사용하는 프로젝트도 규모 커지면 커질수록 
    모듈의 필요성은 커져갔고 그렇게 AMD 방식과 CommonJS 방식 두개의 
    모듈 정의 규칙이 생기게 되었다.

    사실 두개 말고도 ES2016, ES6, System.register 등등의 
    모듈제공 방식도 있지만 여러분의 정신건강을 위해 비밀로한다.
    (밑에서 나올 내용)

동적 로딩이란? (Dynamic Loading)

    실행 시간동안 애플리케이션이 클래스를 로딩하는 것을 의미한다.    
    정적로딩은 미리 메모리를 잡아놓고 사용하고
    동적로딩은 필요할때 메모리를 잡아서 사용하는 것이다. 

AMD
    
    AMD는 Asynchronous Module Definition (비동기 모듈 정의) 규칙이다.

    브라우저에서 모듈을 정의하고 불러오는 기능을 사용하기 위해서는
    AMD의 규칙을 따르는 도구를 사용해야 하는데,
    RequireJS를 사용해보자.

    비동기식 모듈 정의 ( AMD ) API는 모듈 및 그 종속성을 
    비동기 적으로로드 할 수 있도록 모듈을 정의하는 메커니즘을 지정합니다. 
    이것은 모듈의 동기 로딩이 성능, 유용성, 디버깅 및 도메인 간 
    액세스 문제를 유발하는 브라우저 환경에 특히 적합합니다.

기타 -

    AMD와 CommonJS 둘 모두 프론트엔드 브라우저에서 동적 로딩을 할 경우
    페이지가 열리기 전까지 수많은 JS를 사용자가 페이지를 열어볼 때 
    불러오므로 부하가 발생하게 된다. (캐시를 해도 느린건 마찬가지)
    몇 백개의 자바스크립트를 매 사용자가 페이지를 전환할 때마다
    불러 온다고 생각해보자.

    AMD, CommonJS 모두 비동기 통신을 통해 파일을 동적으로
    불러오는 경우 성능의 이슈가 있기 때문에
    보통 프로덕션 서버로 배포 할 때 번들링(Bundling)작업을 진행하게
    된다.

    AMD는 define 함수와 require 함수를 통해 모듈 정의와 로딩을 진행하는데
    이 두가지 함수 모두 브라우저에서 인식 할 수 있는 함수가 아니다.
    따라서 우리는 require.js 스크립트를 추가적으로 불러와
    브라우저에서도 모듈 정의와 로딩이 동작하도록 한다.
    하지만 라이브러리에서 require.js 파일을 의존하여
    같이 빌트-인 하기에는 require.js 소스코드 용량이 크므로
    RequireJS측에서는 미니마이즈 버젼인 Almond(아몬드)를 제공한다.

    여러가지 유명 자바스크립트 라이브러리를 살펴봐도
    대부분 아몬드를 빌트인 하여 제공하고 있다.

CommonJS

    Node.js 진영에서는 CommonJS를 기본으로 사용하고 있다.
    당연하게도 Node.js에서 모듈을 불러오는 기본 스타일이
    CommonJS이기 때문에 프론트앤드 라이브러리일지라도
    Node.js 코드를 통해 유닛 테스팅을 하는 경우
    혹은 moment(시계, 시간 관련 라이브러리), 
    underscore(함수관련 라이브러리)처럼 Node.js에서도 사용
    가능해야 하는 라이브러리 일 경우 CommonJS모듈 형태도
    제공해야 한다. (프론트 단에서 제공해야함)

번들링

    쉽게 설명하자면 여러분의 모듈들을 하나의 단일 파일로
    취합하는 과정이다.
    앞서 언급된 모듈 타입(AMD,CommonJS,ES2015,ES6 etc)을 분석하고
    거기서 불러오는 파일을 파악하여 하나로 모아주는
    번들러(bundler), 묶음 역할을 한다.

    많이 사용하는 번들러의 종류는 웹팩, rollup.js Jspm Browserify
    이 있는데 우리는 Webpack을 사용하도록 하자. (정신건강에 좋음)


기타 - JavaScript IIFE 이해하기 (즉시 호출 함수 표현식?)

    IIFE(Immediately Invoked Function Expressions)은
    즉시 호출 함수 표현식의 줄임말입니다.

    전역 영역(Global Scope)를 오염시키지 않기 위해서 사용됩니다.

        주된 이유는 변수를 전역(global scope)로 선언하는 것을
        피하기 위해서 입니다. 많은 JavaScript 라이브러리와 전문가들이
        이 기법을 사용합니다. 지역 변수를 익명 함수로 위치시켜
        외부와의 충돌을 방지할 수 있습니다.
    
    즉 주요 이유는 전역 함수와 지역 함수 구분을 위한 
    클로저 정의를 위해 사용하는 것이다.

        
용어

    - Full : 컴파일러와 런타임을 포함.

    - Compiler : 템플릿 문자열을 JavaScript 렌더링 함수로 컴파일
                 하는 코드입니다.

    - Runtime : Vue 인스턴스 생성, 가상 DOM 렌더링 및 패치 등을
                담당하는 코드. 기본적으로 모든 컴파일러를 제외한 것.

    - UMD : UMD 빌드는 <script> 태그를 통해 브라우저에서 직접 사용할
            수 있다.  https://unpkg.com/vue의 Unpkg CDN의 기본 파일은 
            Runtime + Compiler UMD 빌드 (vue.js)입니다.

    -CommonJS : CommonJS 빌드는 browserify 또는 Webpack 1 과 같은
                이전 번들과 함께 사용하기 위한 것입니다.
                이러한 번들(pkg.main)의 기본 파일은 런타임 전용
                CommonJS 빌드(vue.runtime.common.js)입니다.
    
    -Es module : ES 모듈 빌드는 webpack2 또는 rollup 과 같은 최신 번들
                 과 함께 사용하기 위한 것입니다. 이러한 번들(pkg.module)
                 의 기본 파일은 런타임 전용 ES모듈 빌드(vue.runtime.esm.js)
                 입니다.
    
Runtime + Compiler vs. Runtime-only

    템플릿을 즉석에서 컴파일 해야하는 경우(예 : 문자열을 template 옵션에
    전달하거나 템플릿으로 in-DOM HTML을 사용하여 요소에 마운트하는 경우)
    컴파일러가 필요하므로 전체 빌드가 필요합니다.

    // 아래 내용은 컴파일러가 필요합니다
    new Vue({
        template: '<div>{{ hi }}</div>'
    })

    // 아래는 필요하지 않습니다
    new Vue({
        render (h) {
        return h('div', this.hi)
        }
    })

    vue-loader 또는 vueify를 사용할 때 *.vue 파일의 템플릿은 빌드시 
    JavaScript로 미리 컴파일됩니다. 최종 번들에 컴파일러가 실제로 
    필요하지 않으므로 런타임 전용 빌드를 사용할 수 있습니다.
    런타임 전용 빌드는 전체 빌드보다 약 30% 정도 작아서 언제든지 
    사용할 수 있습니다. 하지만 전체 빌드를 사용하려면 번들러에서 
    별칭을 구성해야 합니다.

Webpack

    module.exports = {
        // ...
        resolve: {
            alias: {
                'vue$': 'vue/dist/vue.esm.js' 
                // 'vue/dist/vue.common.js'  webpack 1용 입니다
            }
        }
    }


CSP 환경

    Google 크롬 앱과 같은 일부 환경에서는 CSP(컨텐츠 보안 정책)를
    적용하여 표현식을 평가하는 데 new Function() 을 사용할 수 없습니다.
    전체 빌드는 이 기능을 사용하여 템플릿을 컴파일하므로 이러한 환경에서는
    사용할 수 없습니다.

    반면 런타임 전용 빌드는 CSP와 완벽하게 호환됩니다.
    Webpack + vue-loader 또는 Browserify + vueify 로 런타임 전용
    빌드를 사용하는 경우 템플릿은 CSP 환경에서 완벽하게 작동하는 render
    함수로 미리 컴파일됩니다.

개발용 빌드

    중요합니다 : Github의 /dist 폴더에 있는 빌드된 파일은 릴리즈 중에만
                체크인 됩니다.(dist는 distribute, 배포라는 뜻이다.
                배포되는 파일이 들어있는 디렉토리라고 이해하면 된다.)
                Github의 최신 코드에서 Vue를 사용하려면 직접 빌드해야
                합니다.

                git clone https://github.com/vuejs/vue.git node_modules/vue
                cd node_modules/vue
                npm install
                npm run build

Bower

    Bower는 웹 프론트엔드 개발에 필요한 각종 라이브러리들을 관리할 수 있는
    npm, maven, gem과 같은 패키지 매니저입니다.

    (웹 프론트엔드에서 자주 사용하는 jQuery, Bootstrap과 같은 라이브러리들을
    간편하게 관리, 설치할 수 있다.)

    Bower에서는 UMD 빌드만 사용 가능합니다.

AMD 모듈 로더

    모든 UMD빌드는 AMD 모듈로 직접 사용할 수 있습니다.

배포

    자바스크립트 프론트앤드 환경에서는 제공하는 라이브러리를
    어떤식으로 호출 할지 모른다.

    - require([“], function(module) {})로 사용 할 수도 있고. (AMD)

    - var module = require(”)로 사용 할 수도 있다. (CommonJS)

    - 심지어 import { module } from “; 형태로 사용 할 수도 있다. (ES6)

    우리는 이런 모듈 방식을 모두 제공하는 팩토리 형태를 만들어야 한다.

    심지어 이 팩토리 표현에 대해서는 마땅한 표준도 없다.

    표준은 아니지만 UMD라는 친구가 있는데
    Universal Module Definition의 약자이다.
    여기서 제공하는 템플릿이 그래도 많이 사용되고 있는 듯 보인다.

mocking이란?

    주로 단위 테스트에 사용된다.
    실제 개체의 동작을 시뮬레이트하는 모의(mock)사용.
    실제 객체의 동작을 시뮬레이션하는 객체를 만드는 것입니다.

    * Node.js 환경에서는 window, document가 존재하지 않기 때문에
      window와 document를 jsdom을 통해 Mocking 하고있다.


결론

    결론적으로 아직 자바스크립트의 모듈링 표준은 걸음마 단계이다.
    아직 ECMA 6가 모든 브라우저에서 채택되지 않았기 때문에
    과도기적인 면모를 보인다.

    ECMA 6가 AMD와 CommonJS 스타일을 사용하지 않기 때문에 나중에는 
    AMD와 CommonJS 모두가 버려지는 아름다운 현상이 일어날 수도 있다.
    (2017년 3월 글이므로 ES6을 따라가자.)

출처 : https://blog.pigno.se/post/157992405313/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88-%EC%A0%9C%EA%B3%B5%EC%9D%84-%EC%9C%84%ED%95%9C-amd-commonjs-%EA%B7%B8%EB%A6%AC%EA%B3%A0-requirejs-%EC%86%8C%EA%B0%9C

-----------------------------------------------------------------

Vue.js를 시험해 볼 수 있는 가장 쉬운 방법은 
JSFiddle Hello World 예제를 사용하는 것입니다. 

https://jsfiddle.net/chrisvfritz/50wL7mdz/


(여기까지 공부했다. https://kr.vuejs.org/v2/guide/index.html)

-----------------------------------------------------

CDN(콘텐츠 전송 네트워크 - 트래픽 과부하 줄이는 전송 방식) 추가시 형식



<script src="https://unpkg.com/vue@2.5.16/dist/vue.js"></script>


<script>

    var app = new Vue({

        el: ,

        data: {

            

        },

        computed:  {



        },

        methods: {

        }
    });

</script>




----------------------------------------------------

자바스크립트 메소드

map은 콜백 함수의 리턴을 모아서 새로운 배열을 만드는 것이 목적입니다.

filter 메소드는 이름 그대로 요소들을 걸러내는 것이 목적입니다.



자바스크립트 메세지 뒤집기 : message.split('').reverse().join('');

    메시지라는 변수를 any character 로 각각 쪼갠 배열을 만들어서
    그 배열 순서를 뒤집고 다시 배열을 string으로 합친다.


뷰 문법

v-bind:data = 축약형인 :data

v-on:click = 축약형인 @click 

v-text="" 태그의 텍스트 노드에 ""값을 넣어줌

v-if = true일때 v-text 출력 / false면 출력 x


v-for = " 풀어줄 연관배열의 단수형이름 in data안의 연관배열(복수형)

        예 : tasks 라는 연관배열을 task라는 단수형으로 풀어준다. ( = foreach )

            <li v-for="task in tasks"></li>

            li태그의 속성에 추가로 v-text="task.description" 을 써주면 각 task의 description        
            속성을 랜더링해준다.

            li태그의 속성에 추가로 v-if="task.completed" 써주면
            
            completed속성의 값이 true인 것만 랜더링한다.

            *뷰의 computed는 리액티브적으로 작동하므로 데이터의 tasks에서
            한 인덱스의 completed속성의 값을 false를 true 로 바꿔줘도 화면에 반영되어 렌더링된다.


computed Property?

    뷰에서 미리 속성을 계산해놓고 필요할 때 렌더링하자.
    뷰 인스턴스에서 computed 속성을 만들어서 그 안에
    메소드를 미리 만들어 두면 된다.

ES6 에 기반한 함수 짜는법 (ES5와 비교)

    ES5 

        tasks.filter(function (task) {
            return ! task.completed;
        })

    ES6

        tasks.filter(task => ! task.completed);


캐쉬에 남아있는 경우? 새로고침해야 바뀌는 경우. -> Immediately return 방식

캐쉬에 남아있던말던 바로 반영되는 경우 -> Reactive 방식

* 뷰를 이용하면 얼마나 다이나믹하고(동적이고) 쉬운지 알 수 있다!

-------------------------------------

components

    1.우선 main.js 를 만들자.

    2. Vue.component('task', {

        template:'<li>foobar</li>

        }) 를 입력하자.

    어디서든 쓸 수 있는 글로벌 뷰 컴포넌트가 생성되었다.


    3. new Vue({

        el:'#root'

        }

        도 입력해주자.

    
    4. index.html 에서 id가 root 인 div 태그를 만들어놨었다고 가정하고
        그 안에 <task></task> 를 써보자.
        설정해둔 글로벌 뷰 컴포넌트가 나타나는 것을 확인할 수 있다.
    

* Vue.component('task', {

        template:'<li><slot></slot></li>

        })

        으로 바꿔주면 슬롯 부분이 HTML에서 태그 안에
        적는 텍스트 부분임을 의미한다.

        즉 뷰 컴포넌트에 슬롯을 추가한 상태에서 index.html에 
        <task>텍스트</task> 쓰면 화면상에는 <li>텍스트</li>를 
        출력한다는 것.

뷰 컴포넌트를 사용하면 이름을 줄 수 있고
탬플릿을 줄 수 있고 data도 줄 수 있음.

* 컴포넌트는 싱글 인스턴스와 연결되어 있지 않으므로
    데이터를 함수로 해서 오브젝트를 return 해주어야 한다.

----------------------------------------------------

뷰 컴포넌트의 기본 구조 예시

    HTML 
    
        <task-list></task-list>


    main.js

        Vue.component('task-list', {

            template: '
            
                <div>
                
                    <task v-for="task in tasks'>{{ task.task }}</tesk>
                    
                </div>
                
            ',

            data() {

                return {

                    tasks [

                        { task: 'Go to the store', complete: true },

                        { task: 'Go to the email', complete: false },

                        { task: 'Go to the farm', complete: true },

                        { task: 'Go to work', complete: false }

                    ]

                };

            }

        });


        Vue.componet('task', {
            template '<li><slot></slot></li>'
        });

        new Vue((

            el: '#root'

        ));



-----------------------------------------------------

선언적 렌더링

 Vue.js의 핵심은 간단한 탬플릿 구문을 사용해 선언적으로 DOM에 데이터를 렌더링하는 것입니다.


    <div id="app">
        {{ message }}
    </div>

    var app = new Vue({
        el: '#app',
        data: {
            message: '안녕하세요 Vue!'
        } 
    })

-----------------------------------------------------

Vue는 입력과 앱 상태를 양방향으로 바인딩하는 v-model 디렉티브를 제공합니다.

--------------------------------------------------------


사용자 입력 핸들링

    사용자가 앱과 상호 작용할 수 있게 하기 위해 우리는 v-on 디렉티브를 사용하여 Vue 인스턴스에 메소드를 호출하는 이벤트 리스너를 첨부 할 수 있습니다 :

    <div id="app-5">
        <p>{{ message }}</p>
    <button v-on:click="reverseMessage">메시지 뒤집기</button>
    </div>

    var app5 = new Vue({
        el: '#app-5',
        data: {
        message: '안녕하세요! Vue.js!'
    },

    methods: {
            reverseMessage: function () {
                this.message = this.message.split('').reverse().join('')
            }
        }
    })

------------------------------------------------------

컴포넌트를 사용한 작성방법

Vue에서, 컴포넌트는 본질적으로 미리 정의된 옵션을 가진 Vue 인스턴스 입니다. Vue에서 컴포넌트를 등록하는 방법은 간단합니다.

    // todo-item 이름을 가진 컴포넌트를 정의합니다
    Vue.component('todo-item', {
     template: '<li>할일 항목 하나입니다.</li>'
    })

    이제 다른 컴포넌트의 템플릿에서 이 컴포넌트를 사용할 수 있습니다.

    <ol>
     <!-- todo-item 컴포넌트의 인스턴스 만들기 -->
     <todo-item></todo-item>
    </ol>

-------------------------------------------------------

* 컴포넌트를 사용하여 부모 영역의 데이터를 자식 컴포넌트에 집어넣을 수 있다.

    대규모 응용 프로그램에서는 개발 과정을 관리할 수 있는 수준 하에 두기 위해 전체 앱을 컴포넌트로 나누는 것이 필수적입니다.

    자식 앱인 컴포넌트를 이용하여 부모 앱인 뷰 인스턴스에 영향을 주지 않으면서 개발이 가능합니다.


* 컴포넌트를 사용한 앱의 모습이 어떻게 구성될지에 대한 (상상의) 예를 제시하겠습니다.

<div id="app">
  <app-nav></app-nav>
  <app-view>
    <app-sidebar></app-sidebar>
    <app-content></app-content>
  </app-view>
</div>

즉 Vue.js를 이용하여 프론트앤드 단에서도 부품, 모듈화를 시켜서 작성이 가능하다는 것.

---------------------------------------------------------

* 모든 Vue 컴포넌트는 본질적으로 Vue 인스턴스로부터 확장된 것임을 알아야 합니다.

    Root instance 를 통해 확장된 컴포넌트로 구성되어 있다.

    아래는 뷰 앱 구조 예시이다.
    
    ex) Root Instance ( 루트 뷰 인스턴스. 컴포넌트 입장에서는 부모이다. )
        └─ TodoList ( 아래부터는 확장된 뷰 루트 인스턴스의 자식 컴포넌트들을 의미한다. )
            ├─ TodoItem
            │  ├─ DeleteTodoButton
            │  └─ EditTodoButton
            └─ TodoListFooter
                ├─ ClearTodosButton
                └─ TodoListStatistics        

---------------------------------------------------------

Proxy, 프록시 란?

    Proxy는 일반적으로 대리자/대리인을 의미하며 말 그대로 작업을 대신 수행하거나 중개해주는 역할을 하는 객체를 의미합니다.

    기존 소스를 수정하지 않고 객체의 행동을 다양한 방식으로 제어할 수 있기 때문에, Proxy 패턴은 현대 프레임워크에서 매우 중요한 역할을 담당합니다.

---------------------------------------------------------

자바스크립트 토막지식

* Object.freeze() 메서드는 객체를 얼려 버립니다.  얼려 버린다는 것은 객체에 새로운 속성(property)를 추가할 수 없고, 
  객체에 원래 존재하던 속성을 제거할 수 없으며, 객체의 속성, 열거가능성(enumerability), 설정가능성(configurability), 
  값 쓰기 가능성(writability)을 변경할 수 없게 만든다는 것을 의미합니다. Object.freeze() 메서드는 결국 객체를 불변(immutable) 객체로 만들어 줍니다. 
  Object.freeze() 메서드는 얼려진, 즉, 불변화 된 객체를 반환합니다.

--------------------------------------------

Mustache - 수많은 언어에서 지원되는 초간단 탬플릿 문법 (예 : Angular, Vue.js)

    콧수염처럼 생겨서 머스타치

    {{ }}

--------------------------------------------

자바스크립트 토막지식 - 이벤트 버블링

    https://hyunseob.github.io/2015/08/01/bind-same-event/ 참고

-----------------------------------

* Vue.js는 모든 데이터 바인딩 내에서 JavaScript 표현식의 모든 기능을 지원합니다.

    - 표현식은 Vue 인스턴스 데이터 범위 내에서 JavaScript로 계산됩니다. 한가지 제한사항은 각 바인딩에 하나의 단일 표현식 만 포함될 수 있으므로 아래처럼 작성하면 안됩니다

        <!-- 아래는 구문입니다, 표현식이 아닙니다. -->
        {{ var a = 1 }}

        <!-- 조건문은 작동하지 않습니다. 삼항 연산자를 사용해야 합니다. -->
        {{ if (ok) { return message } }}

    각 바인딩에 하나의 단일 표현식만 포함될 수 있다는 점을 꼭 기억하도록 하자!


    * 템플릿 표현식은 샌드박스(보호된 영역에서 동작) 처리되며 Math와 Date 같은 전역으로 사용 가능한 것에만 접근할 수 있습니다. 템플릿 표현식에서 사용자 정의 전역에 액세스 하지 마십시오.

------------------------------------

샌드박스(Sandbox) 기술이란?

    샌드박스란 미국에서 어린아이를 보호하기 위해 모래통(Sandbox)에서만 놀도록 하는데서 유래한 보안 모델을 말합니다.

    즉, 외부 접근 및 영향을 차단하여 제한된 영역 내에서만 프로그램을 동작시키는 것입니다. 
    샌드박스 내에서 어떤 파일이나 프로세스가 안전하지 못하다고 판명되면, 외부로의 접근을 차단하여 시스템에 피해를 입히는 것을 방지합니다.

    예를 들어 악성 프로그램이나 악성코드의 경우, 본래의 공격행위를 하더라도 실제 시스템 내 파일이나 프로세스를 감염시킬 수 없습니다. 
    이러한 특징들로 말미암아 가상화를 통한 보안으로서 악성코드를 감지하고 분석하는데 사용되는 기술입니다.

    그러나 샌드박스 기술이 기존 시그니처 기반 탐지의 한계를 극복하는 대안으로 각광받자, 해커들은 샌드박스를 탐지 및 우회하는 악성코드를 만들어 냈습니다. 
    악성코드가 동작하는 환경이 샌드박스로 감지되면 C&C 주소를 숨기거나 다른 HTTP 리퀘스트를 사용하여 보안업체로 하여금 악성코드를 분석하는 것을 방해합니다. 
    혹은 해당 환경설정이나 IP주소를 수집하여 C&C서버로 전송하는 등 분석을 시도하는 보안업체의 정보를 파악하는 지능형 악성코드 군도 존재합니다.

    샌드박스 기술이 APT공격의 주요 보안 솔루션이지만, 이를 우회하는 악성코드가 존재하는데다가 가상화 공간에서 동작을 수행하는데 시간이 다소 걸린다는 단점도 있습니다. 
    이러한 이유로 샌드박스 기술은 기존 보안 솔루션들을 보완하는 차원에서 통합으로 사용되는 경우도 있습니다.

-------------------------------------

* 보안 관련 이슈들 배경지식 참고

    https://www.estsecurity.com/securityCenter/commonSense/1?

-------------------------------------

프로그래밍 용어

Side Effect 란?

    쉽게 말해서 실행 중에 어떤 객체를 접근해서 변화가 일어나는 행위(라이브러리 I/O, 객체 변경 등)입니다.

    예제를 한 번 보겠습니다.

    x = 3 + 4;
    위의 표현식은 1개의 side effect가 있습니다. x의 값이 변경되었기 때문입니다. .

    y = x++;
    위의 표현식은 총 2개의 side effect가 있습니다. x++에서 x가 한 번 변하고, x 값 대입으로 y가 한 번 변합니다.

    3 + 4;
    위 표현식은 side effect가 없습니다.

    if(flag){
        foo();
    }
    위 표현식은 flag가 true일 경우에 한해서 잠재적으로 side effect 가 있습니다.

    예시)

        sizeof 에서 잘못 사용
            sizeof는 보통 어떤 변수나 타입의 크기를 알아낼 때 사용됩니다. 하지만 종종 아래와 같이 sizeof 안에 side effect를 일으키는 연산을 적는 경우가 있습니다.

            int a = 14;
            int b = sizeof(a++);

            안전하게 사용하려면 sizeof 에는 어떠한 side effect도 일어나지 않도록 프로그래밍 해야 합니다.

------------------------------------------

디렉티브
    
    디렉티브는 v- 접두사가 있는 특수 속성입니다. 디렉티브 속성 값은 단일 JavaScript 표현식 이 됩니다. (나중에 설명할 v-for는 예외입니다.) 
    디렉티브의 역할은 표현식의 값이 변경될 때 사이드이펙트를 반응적으로 DOM에 적용하는 것 입니다. 아래 예제에서 살펴보겠습니다.

    ex)

        <p v-if="seen">이제 나를 볼 수 있어요</p>
        
        여기서, v-if 디렉티브는 seen 표현의 진실성에 기반하여 <p> 엘리먼트를 제거 또는 삽입합니다.

-------------------------------------------

수식어

    수식어는 점으로 표시되는 특수 접미사로, 디렉티브를 특별한 방법으로 바인딩 해야 함을 나타냅니다. 
    예를 들어, .prevent 수식어는 트리거된 이벤트에서 event.preventDefault()를 호출하도록 v-on 디렉티브에게 알려줍니다.

<form v-on:submit.prevent="onSubmit"> 내용 </form>

나중에 v-on과 v-model을 더 자세히 살펴볼 때 수식어를 더 많이 사용할 것 입니다.

-----------------------------------------------

약어

    v- 접두사는 템플릿의 Vue 특정 속성을 식별하기 위한 시각적인 신호 역할을 합니다. 
    이 기능은 Vue.js를 사용하여 기존의 마크업에 동적인 동작을 적용할 때 유용하지만 일부 자주 사용되는 디렉티브에 대해 너무 장황하다고 느껴질 수 있습니다. 
    동시에 Vue.js가 모든 템플릿을 관리하는 SPA를 만들 때 v- 접두어의 필요성이 떨어집니다. 
    따라서 가장 자주 사용되는 두개의 디렉티브인 v-bind와 v-on에 대해 특별한 약어를 제공합니다.

    SPA 란? Single-page application 을 의미한다.

    v-bind 약어

        <!-- 전체 문법 -->
        <a v-bind:href="url"> ... </a>

        <!-- 약어 -->
        <a :href="url"> ... </a>

    v-on 약어

        <!-- 전체 문법 -->
        <a v-on:click="doSomething"> ... </a>

        <!-- 약어 -->
        <a @click="doSomething"> ... </a>

    이들은 일반적인 HTML과 조금 다르게 보일 수 있습니다. 하지만 :와 @는 속성 이름에 유효한 문자이며 Vue.js를 지원하는 모든 브라우저는 올바르게 구문 분석을 할 수 있습니다. 
    또한 최종 렌더링 된 마크업에는 나타나지 않습니다. 약어는 완전히 선택사항이지만 나중에 익숙해지면 편할 것 입니다.

    * 자주 사용하는 v-on 이나 v-bind 인 경우 약어를 사용할 수 있게 되어있다!

---------------------------------------------------

Vue.js가 말하는 AngularJS와 뷰JS의 차이점


    AngularJS (Angular 1)
        
        일부 Vue의 문법은 Angular와 매우 유사합니다 (예 :v-if와ng-if). Angular가 제대로 된 많은 것들을 가지고 있었기 때문에 이것은 개발 초기에 Vue에게 영감이 되었습니다. 
        Angular와 함께 제공되는 많은 고통이 있었지만 Vue가 상당한 개선을 제공하려고 시도하였습니다.

    복잡도

        Vue는 API와 디자인면에서 Angular 1보다 훨씬 간단합니다. 평범하지 않은 애플리케이션을 작성하기에 충분한 학습기간은 일반적으로 1 일 미만으로 소요되며 Angular 1에서는 그렇지 않습니다.

    유연성과 모듈성

        Angular는 애플리케이션을 어떻게 구성해야 하는지에 대한 강요가 강하고 Vue는 더욱 유연하고 모듈방식의 솔루션입니다. 이로 인해 Vue는 다양한 프로젝트에보다 적합하게 적용될 수 있으며, 
        때로는 코딩을 시작하기 위해 의사 결정을 내리는데 유용 할 때가 있습니다.

        그렇기 때문에 핫 모듈 리로딩, 린트 (linting), CSS 추출과 같은 고급 기능에 대한 액세스 권한을 부여하는 동시에 빠르게 설정할 수있는 Webpack 템플릿을 제공합니다.

    데이터 바인딩

        Angular 1은 스코프간 양방향 바인딩을 사용하는 반면 Vue는 컴포넌트 간에 단방향의 데이터 흐름을 사용합니다. 이로 인해 데이터의 흐름이 단순한 애플리케이션에서는 데이터의 흐름을 쉽게 파악할 수 있습니다.

    디렉티브 vs 컴포넌트

        Vue는 디렉티브와 컴포넌트를 명확하게 구분합니다. 지시어는 DOM 조작만 캡슐화 하기 위한 것이고 컴포넌트는 자체 뷰와 데이터 로직이 있는 자체의 포함 단위입니다. Angular에서는 이 둘 사이에 많은 혼란이 있습니다.


그렇다면 Vue.js 최신 Angular 와의 차이점은?

    Angular (Formerly known as Angular 2)

        Angular 2는 완전히 새로운 것이기 때문에 별도의 섹션을 만들었습니다. 예를 들어, 1급 컴포넌트 시스템이 있으며 많은 구현 세부 사항이 완전히 다시 작성 되었으며 API도 상당히 크게 변경되었습니다.


    TypeScript

        Angular는 TypeScript가 필수적입니다. 문서 또한 TypeScript 기반입니다. TypeScript를 사용하면 Java와 C#을 다루던 사용자에게 생산성을 올려주고 정적 타입 체크 등의 많은 이익이 있습니다. 
        그러나 모든 사람들이 TypeScript를 사용하려고 하지는 않습니다.

        많은 소규모 사례에서 TypeScript를 사용하면 생산성 향상보다 더 많은 오버헤드가 발생할 수 있습니다. 
        이 경우 TypeScript 없이 Angular를 사용하는 것이 어려울 수 있기 때문에 Vue를 사용하는 것이 좋습니다.

        Vue는 엔터프라이즈 환경에도 매우 적합하며 공식 Typings 및 공식 decorator를 통해 TypeScript와 함께 사용할 수도 있습니다.

    학습 곡선

        Vue를 시작하려면 HTML 및 ES5 JavaScript (즉, 일반 자바 스크립트)에 익숙해야합니다. 이러한 기본 기술을 사용하면 안내서를 읽는 하루 만에 작은 애플리케이션을 작성할 수 있습니다.

        Angular의 학습곡선은 훨씬 가파릅니다. 프레임워크 API는 방대하며 생산성이 올라가기 전에 매우 많은 것들을 알아야합니다. 
        Angular의 복잡성은 대규모 앱을 목표로 합니다. 하지만 경험이 부족한 개발자가 선택하기에 훨씬 어렵습니다.

----------------------------------------------------


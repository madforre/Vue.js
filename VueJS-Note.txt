Vue.js란 무엇인가?

    Vue(/vjuː/ 로 발음, view 와 발음이 같습니다.)는
    사용자 인터페이스를 만들기 위한 진보적인 프레임워크 입니다.
    다른 단일형 프레임워크와 달리 Vue는 점진적으로 채택할 수 있도록
    설계하였습니다. 핵심 라이브러리는 뷰 레이어만 초점을 맞추어
    다른 라이브러리나 기존 프로젝트와의 통합이 매우 쉽습니다.
    그리고 Vue는 현대적 도구 및 지원하는 라이브러리와 함께 사용한다면
    정교한 단일 페이지 응용프로그램을 완벽하게 지원할 수 있습니다.

호환성 정보

    Vue는 ECMAScript 5 기능을 사용하기 때문에
    IE8 이하 버전을 지원하지 않습니다.
    하지만 모든 ECMAScript 5 호환 브라우저를 지원합니다.

Vue Devtools

    Vue를 사용할 때, 브라우저에 Vue Devtools를 설치하세요.
    Vue 앱을 보다 사용자 친화적으로 검사하고 디버그할 수 있습니다.

직접 <script>에 추가

    다운로드 받아 script 태그에 추가하기만 하면 됩니다.
    Vue는 전역 변수로 등록됩니다.

    (개발 중에는 최소화 버젼을 사용하지 마십시오. 일반적인 실수에
    대한 모든 훌륭한 경고를 놓치게됩니다!)

    *개발중에는 개발용 버젼을 사용하자(디버그 제공)
    배포용 버젼은 경고가 제거된다.(최소화 버젼)

NPM

    Vue로 대규모 응용 프로그램을 빌드할 때 NPM을 권장합니다.
    Webpack 또는 Browserify와 같은 모듈 번들러와 잘 작동합니다.
    Vue는 싱글 파일 컴포넌트를 만들기 위한 도구도 제공합니다.

        npm install Vue

CLI

    Vue.js는 단일 페이지 응용 프로그램을 빠르게 스캐폴딩하기 위한 공식
    CLI를 제공합니다. 현대적인 프론트엔드 워크플로우를 위해 잘 구성된
    빌드 설정을 제공합니다. 핫 리로드, lint-on-save 및 프로덕션 준비가 된
    빌드로 시작하고 실행하는데 몇 분 밖에 걸리지 않습니다.

        npm install --global vue-cli

        vue init webpack my-project

        cd my-project

        npm install

        npm run dev

기타 - package.json 생성

    package.json을 생성하려면 프로젝트 루트에서 npm init
    명령어를 실행한다.

    npm init 명령어를 사용하면 프로젝트에 대한 여러 가지 정보를
    입력하도록 요구받는다.

기타 - 나이트왓치

    나이트왓치는 노드 기반의 E2E 테스트 프레임워크다.
    (배보다 배꼽이 더 큰 경우가 발생할 수 있음.)
    충분한 전문성과 기회비용을 필요로 한다.

각 다른 빌드간 차이점

            	    UMD           	CommonJS	            ES Module

Full    	        vue.js	        vue.common.js	        vue.esm.js

Runtime-only	    vue.runtime.js  vue.runtime.common.js	vue.runtime.esm.js

Full (production)	vue.min.js	        -	                    -

Runtime-only        vue.runtime.min.js	-	                    -
(production)

    AMD(Asynchronous Module Definition)

        비동기 모듈 정의(AMD) 포맷은 브라우저에서
        사용되고 define 함수를 사용해서 모듈을 정의한다.

    UMD(Universal Module Definition)

        만능 모듈 정의(UMD)로, 브라우저와 Node.js에서
        둘 다 사용될 수 있다.

    CommonJS 포맷

        Node.js에서 사용되고 require와 module.exports
        를 사용해서 의존성과 모듈을 정의한다.

    ES6 모듈 포맷

        ES6에서 자바스크립트는 내장된 모듈 포맷도 지원한다.

        모듈의 공개 API로 내보내기 위해 export 토큰을 사용한다.
        import는 모듈이 내보내는 부분을 가져온다.
        as를 사용하여 가져오는 모듈에 별명을 줄 수도 있다.
        전체 모듈을 한 번에 로드할 수도 있다. (* 사용)
        default export도 지원한다. (사용하면 모듈을 가져올 때
        괄호 {}를 사용하지 않아도 되며, 단일 값을 내보낼 때 사용한다.)
        함수 뿐만 아니라 어떤 것이든 내보낼 수 있다.
        불행하게도 내장된 모듈 포맷은 아직 모든 브라우저에서 지원되지
        않는다.
        그래서 우리는 이미 ES6 모듈 포맷을 사용할 수 있지만,
        브라우저에서 코드를 실행하기 전에 Babel과 같은
        변환기를 사용해 ES5 모듈 포맷(AMD 또는 CommonJS)로 코드
        변환이 필요하다.

    모듈 로더

        모듈 로더는 주요 모듈 포맷으로 작성된 모듈을 해석하고 로드한다.
        모듈 로더는 런타임에 실행된다.

        - 브라우저에서 모듈 로더를 로드한다.
        - 모듈 로더에게 어떤 메인 애플리케이션 파일을 로드할 것인지 알려준다.
        - 모듈 로더는 메인 애플리케이션 파일을 다운로드하고 해석한다.
        - 필요한 경우 모듈 로더가 파일을 다운로드한다.

        브라우저 개발자 콘솔에서 네트워크 탭을 열면, 모듈 로더에 의해
        많은 파일들이 로드된 것을 볼 수 있다.

        인기 있는 모듈 로더로는 RequireJs, SystemJS 가 있다.

    모듈 번들러

        모듈 번들러는 모듈 로더를 대체한다.

        모듈 로더와 반대로 모듈 번들러는 빌드 타임에 실행된다.

        - 빌드 타임에 번들 파일을 생성하기 위해 모듈 번들러를 실행한다.
          (예:bundle.js)
        - 브라우저에서 번들 파일을 로드한다.

        브라우저 개발자 콘솔에서 네트워크 탭을 열면, 모듈 로더에 의해
        1개 파일만 로드된 것을 볼 수 있다.
        브라우저에서 모듈 로더를 필요로 하지 않는다.
        모든 코드는 번들 안에 포함되어 있다.

        인기 있는 모듈 번들에는 다음과 같은 것들이 있다.

        - Browserify : CommonJS 모듈을 위한 번들러
        - Webpack : AMD, CommonJS, ES6 모듈을 위한 번들러

    요약

        모던 자바스크립트 개발 환경에서 툴링을 잘 이해하기 위해서는
        모듈, 모듈 포맷, 모듈 로더와 모듈 번들러 사이의 차이를
        이해하는 것이 중요하다.

        모듈은 구현 세부 사항을 캡슐화하고 공개 API를 노출해
        다른 코드에서 쉽게 로드하고 사용할 수 있도록
        재사용 가능한 코드 조각이다.

        모듈 포맷은 모듈을 정의하기 위해 사용하는 문법이다.
        AMD, CommonJS, UMD, System.register 와 같은
        여러 모듈 포맷이 과거에 등장했으며, ES6부터 내장된 모듈
        포맷을 사용할 수 있다.

        모듈 로더는 주요 모듈 포맷으로 작성된 모듈을 런타임 때
        로드하고 해석한다. RequireJS와 SystemJS가 있다.

        모듈 번들러는 모듈 로더를 대체하고 빌드 타임에 모든 코드의
        번들을 생성한다. Browserify와 Webpack이 있다.

        참조 : https://github.com/codepink/codepink.github.com/wiki/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88,-%EB%AA%A8%EB%93%88-%ED%8F%AC%EB%A7%B7,-%EB%AA%A8%EB%93%88-%EB%A1%9C%EB%8D%94%EC%99%80-%EB%AA%A8%EB%93%88-%EB%B2%88%EB%93%A4%EB%9F%AC%EC%97%90-%EB%8C%80%ED%95%9C-10%EB%B6%84-%EC%9E%85%EB%AC%B8%EC%84%

자바스크립트 모듈 사용의 배경

    자바스크립트는 파이썬, 루비, 다른 스크립트 언어 계열과 차이점이 존재한다.
    바로 모듈 사용의 표준이 존재하지 않다는 것이다. (ECMA5 기준)

    Node.js를 사용하고 있는 개발자들은 module.exports를 통해
    모듈을 정의하고 require() 함수를 통해 정의한 모듈을 불러와
    사용하고 있다. 이러한 방식을 CommonJS라고 부른다.

    Node.js 모듈 형태를 보면 다른언어에 비해 모듈제공이 조금 차이가 있다.
    module.exports와 exports 두개를 사용하는데
    이런 제공방식은 혼동을 초래하기도 한다.
    문제는 프론트엔드에서는 이런 모듈 제공방식이 없었다는 것이다!

    프론트엔드에서 사용하는 자바스크립트는 DOM 오브젝트를 사용하고 있다.
    전역 오브젝트인 window를 사용하면 다른 자바스크립트 파일에
    리소스를 전달 할 수 있다.

    하지만 이것도 사용하는 HTML에서 불러오는 모듈 파일을 먼저 로드해야
    문제가 없이 작동된다.

    즉 대상 모듈이 존재 할 수도, 존재하지 않을 수도 있는 상태가 벌어진다.
    (으아아악!)

    하지만 프론트엔드에서 사용하는 프로젝트도 규모 커지면 커질수록
    모듈의 필요성은 커져갔고 그렇게 AMD 방식과 CommonJS 방식 두개의
    모듈 정의 규칙이 생기게 되었다.

    사실 두개 말고도 ES2016, ES6, System.register 등등의
    모듈제공 방식도 있지만 여러분의 정신건강을 위해 비밀로한다.
    (밑에서 나올 내용)

동적 로딩이란? (Dynamic Loading)

    실행 시간동안 애플리케이션이 클래스를 로딩하는 것을 의미한다.
    정적로딩은 미리 메모리를 잡아놓고 사용하고
    동적로딩은 필요할때 메모리를 잡아서 사용하는 것이다.

AMD

    AMD는 Asynchronous Module Definition (비동기 모듈 정의) 규칙이다.

    브라우저에서 모듈을 정의하고 불러오는 기능을 사용하기 위해서는
    AMD의 규칙을 따르는 도구를 사용해야 하는데,
    RequireJS를 사용해보자.

    비동기식 모듈 정의 ( AMD ) API는 모듈 및 그 종속성을
    비동기 적으로로드 할 수 있도록 모듈을 정의하는 메커니즘을 지정합니다.
    이것은 모듈의 동기 로딩이 성능, 유용성, 디버깅 및 도메인 간
    액세스 문제를 유발하는 브라우저 환경에 특히 적합합니다.

기타 -

    AMD와 CommonJS 둘 모두 프론트엔드 브라우저에서 동적 로딩을 할 경우
    페이지가 열리기 전까지 수많은 JS를 사용자가 페이지를 열어볼 때
    불러오므로 부하가 발생하게 된다. (캐시를 해도 느린건 마찬가지)
    몇 백개의 자바스크립트를 매 사용자가 페이지를 전환할 때마다
    불러 온다고 생각해보자.

    AMD, CommonJS 모두 비동기 통신을 통해 파일을 동적으로
    불러오는 경우 성능의 이슈가 있기 때문에
    보통 프로덕션 서버로 배포 할 때 번들링(Bundling)작업을 진행하게
    된다.

    AMD는 define 함수와 require 함수를 통해 모듈 정의와 로딩을 진행하는데
    이 두가지 함수 모두 브라우저에서 인식 할 수 있는 함수가 아니다.
    따라서 우리는 require.js 스크립트를 추가적으로 불러와
    브라우저에서도 모듈 정의와 로딩이 동작하도록 한다.
    하지만 라이브러리에서 require.js 파일을 의존하여
    같이 빌트-인 하기에는 require.js 소스코드 용량이 크므로
    RequireJS측에서는 미니마이즈 버젼인 Almond(아몬드)를 제공한다.

    여러가지 유명 자바스크립트 라이브러리를 살펴봐도
    대부분 아몬드를 빌트인 하여 제공하고 있다.

CommonJS

    Node.js 진영에서는 CommonJS를 기본으로 사용하고 있다.
    당연하게도 Node.js에서 모듈을 불러오는 기본 스타일이
    CommonJS이기 때문에 프론트앤드 라이브러리일지라도
    Node.js 코드를 통해 유닛 테스팅을 하는 경우
    혹은 moment(시계, 시간 관련 라이브러리),
    underscore(함수관련 라이브러리)처럼 Node.js에서도 사용
    가능해야 하는 라이브러리 일 경우 CommonJS모듈 형태도
    제공해야 한다. (프론트 단에서 제공해야함)

번들링

    쉽게 설명하자면 여러분의 모듈들을 하나의 단일 파일로
    취합하는 과정이다.
    앞서 언급된 모듈 타입(AMD,CommonJS,ES2015,ES6 etc)을 분석하고
    거기서 불러오는 파일을 파악하여 하나로 모아주는
    번들러(bundler), 묶음 역할을 한다.

    많이 사용하는 번들러의 종류는 웹팩, rollup.js Jspm Browserify
    이 있는데 우리는 Webpack을 사용하도록 하자. (정신건강에 좋음)


기타 - JavaScript IIFE 이해하기 (즉시 호출 함수 표현식?)

    IIFE(Immediately Invoked Function Expressions)은
    즉시 호출 함수 표현식의 줄임말입니다.

    전역 영역(Global Scope)를 오염시키지 않기 위해서 사용됩니다.

        주된 이유는 변수를 전역(global scope)로 선언하는 것을
        피하기 위해서 입니다. 많은 JavaScript 라이브러리와 전문가들이
        이 기법을 사용합니다. 지역 변수를 익명 함수로 위치시켜
        외부와의 충돌을 방지할 수 있습니다.

    즉 주요 이유는 전역 함수와 지역 함수 구분을 위한
    클로저 정의를 위해 사용하는 것이다.


용어

    - Full : 컴파일러와 런타임을 포함.

    - Compiler : 템플릿 문자열을 JavaScript 렌더링 함수로 컴파일
                 하는 코드입니다.

    - Runtime : Vue 인스턴스 생성, 가상 DOM 렌더링 및 패치 등을
                담당하는 코드. 기본적으로 모든 컴파일러를 제외한 것.

    - UMD : UMD 빌드는 <script> 태그를 통해 브라우저에서 직접 사용할
            수 있다.  https://unpkg.com/vue의 Unpkg CDN의 기본 파일은
            Runtime + Compiler UMD 빌드 (vue.js)입니다.

    -CommonJS : CommonJS 빌드는 browserify 또는 Webpack 1 과 같은
                이전 번들과 함께 사용하기 위한 것입니다.
                이러한 번들(pkg.main)의 기본 파일은 런타임 전용
                CommonJS 빌드(vue.runtime.common.js)입니다.

    -Es module : ES 모듈 빌드는 webpack2 또는 rollup 과 같은 최신 번들
                 과 함께 사용하기 위한 것입니다. 이러한 번들(pkg.module)
                 의 기본 파일은 런타임 전용 ES모듈 빌드(vue.runtime.esm.js)
                 입니다.

Runtime + Compiler vs. Runtime-only

    템플릿을 즉석에서 컴파일 해야하는 경우(예 : 문자열을 template 옵션에
    전달하거나 템플릿으로 in-DOM HTML을 사용하여 요소에 마운트하는 경우)
    컴파일러가 필요하므로 전체 빌드가 필요합니다.

    // 아래 내용은 컴파일러가 필요합니다
    new Vue({
        template: '<div>{{ hi }}</div>'
    })

    // 아래는 필요하지 않습니다
    new Vue({
        render (h) {
        return h('div', this.hi)
        }
    })

    vue-loader 또는 vueify를 사용할 때 *.vue 파일의 템플릿은 빌드시
    JavaScript로 미리 컴파일됩니다. 최종 번들에 컴파일러가 실제로
    필요하지 않으므로 런타임 전용 빌드를 사용할 수 있습니다.
    런타임 전용 빌드는 전체 빌드보다 약 30% 정도 작아서 언제든지
    사용할 수 있습니다. 하지만 전체 빌드를 사용하려면 번들러에서
    별칭을 구성해야 합니다.

Webpack

    module.exports = {
        // ...
        resolve: {
            alias: {
                'vue$': 'vue/dist/vue.esm.js'
                // 'vue/dist/vue.common.js'  webpack 1용 입니다
            }
        }
    }


CSP 환경

    Google 크롬 앱과 같은 일부 환경에서는 CSP(컨텐츠 보안 정책)를
    적용하여 표현식을 평가하는 데 new Function() 을 사용할 수 없습니다.
    전체 빌드는 이 기능을 사용하여 템플릿을 컴파일하므로 이러한 환경에서는
    사용할 수 없습니다.

    반면 런타임 전용 빌드는 CSP와 완벽하게 호환됩니다.
    Webpack + vue-loader 또는 Browserify + vueify 로 런타임 전용
    빌드를 사용하는 경우 템플릿은 CSP 환경에서 완벽하게 작동하는 render
    함수로 미리 컴파일됩니다.

개발용 빌드

    중요합니다 : Github의 /dist 폴더에 있는 빌드된 파일은 릴리즈 중에만
                체크인 됩니다.(dist는 distribute, 배포라는 뜻이다.
                배포되는 파일이 들어있는 디렉토리라고 이해하면 된다.)
                Github의 최신 코드에서 Vue를 사용하려면 직접 빌드해야
                합니다.

                git clone https://github.com/vuejs/vue.git node_modules/vue
                cd node_modules/vue
                npm install
                npm run build

Bower

    Bower는 웹 프론트엔드 개발에 필요한 각종 라이브러리들을 관리할 수 있는
    npm, maven, gem과 같은 패키지 매니저입니다.

    (웹 프론트엔드에서 자주 사용하는 jQuery, Bootstrap과 같은 라이브러리들을
    간편하게 관리, 설치할 수 있다.)

    Bower에서는 UMD 빌드만 사용 가능합니다.

AMD 모듈 로더

    모든 UMD빌드는 AMD 모듈로 직접 사용할 수 있습니다.

배포

    자바스크립트 프론트앤드 환경에서는 제공하는 라이브러리를
    어떤식으로 호출 할지 모른다.

    - require([“], function(module) {})로 사용 할 수도 있고. (AMD)

    - var module = require(”)로 사용 할 수도 있다. (CommonJS)

    - 심지어 import { module } from “; 형태로 사용 할 수도 있다. (ES6)

    우리는 이런 모듈 방식을 모두 제공하는 팩토리 형태를 만들어야 한다.

    심지어 이 팩토리 표현에 대해서는 마땅한 표준도 없다.

    표준은 아니지만 UMD라는 친구가 있는데
    Universal Module Definition의 약자이다.
    여기서 제공하는 템플릿이 그래도 많이 사용되고 있는 듯 보인다.

mocking이란?

    주로 단위 테스트에 사용된다.
    실제 개체의 동작을 시뮬레이트하는 모의(mock)사용.
    실제 객체의 동작을 시뮬레이션하는 객체를 만드는 것입니다.

    * Node.js 환경에서는 window, document가 존재하지 않기 때문에
      window와 document를 jsdom을 통해 Mocking 하고있다.


결론

    결론적으로 아직 자바스크립트의 모듈링 표준은 걸음마 단계이다.
    아직 ECMA 6가 모든 브라우저에서 채택되지 않았기 때문에
    과도기적인 면모를 보인다.

    ECMA 6가 AMD와 CommonJS 스타일을 사용하지 않기 때문에 나중에는
    AMD와 CommonJS 모두가 버려지는 아름다운 현상이 일어날 수도 있다.
    (2017년 3월 글이므로 ES6을 따라가자.)

출처 : https://blog.pigno.se/post/157992405313/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88-%EC%A0%9C%EA%B3%B5%EC%9D%84-%EC%9C%84%ED%95%9C-amd-commonjs-%EA%B7%B8%EB%A6%AC%EA%B3%A0-requirejs-%EC%86%8C%EA%B0%9C

-----------------------------------------------------------------

Vue.js를 시험해 볼 수 있는 가장 쉬운 방법은
JSFiddle Hello World 예제를 사용하는 것입니다.

https://jsfiddle.net/chrisvfritz/50wL7mdz/


(여기까지 공부했다. https://kr.vuejs.org/v2/guide/index.html)

-----------------------------------------------------

CDN(콘텐츠 전송 네트워크 - 트래픽 과부하 줄이는 전송 방식) 추가시 형식



<script src="https://unpkg.com/vue@2.5.16/dist/vue.js"></script>


<script>

    var app = new Vue({

        el: ,

        data: {



        },

        computed:  {



        },

        methods: {

        }
    });

</script>




----------------------------------------------------

자바스크립트 메소드

map은 콜백 함수의 리턴을 모아서 새로운 배열을 만드는 것이 목적입니다.

filter 메소드는 이름 그대로 요소들을 걸러내는 것이 목적입니다.



자바스크립트 메세지 뒤집기 : message.split('').reverse().join('');

    메시지라는 변수를 any character 로 각각 쪼갠 배열을 만들어서
    그 배열 순서를 뒤집고 다시 배열을 string으로 합친다.


뷰 문법

v-bind:data = 축약형인 :data

v-on:click = 축약형인 @click

v-text="" 태그의 텍스트 노드에 ""값을 넣어줌

v-if = true일때 v-text 출력 / false면 출력 x


v-for = " 풀어줄 연관배열의 단수형이름 in data안의 연관배열(복수형)

        예 : tasks 라는 연관배열을 task라는 단수형으로 풀어준다. ( = foreach )

            <li v-for="task in tasks"></li>

            li태그의 속성에 추가로 v-text="task.description" 을 써주면 각 task의 description
            속성을 랜더링해준다.

            li태그의 속성에 추가로 v-if="task.completed" 써주면

            completed속성의 값이 true인 것만 랜더링한다.

            *뷰의 computed는 리액티브적으로 작동하므로 데이터의 tasks에서
            한 인덱스의 completed속성의 값을 false를 true 로 바꿔줘도 화면에 반영되어 렌더링된다.


computed Property?

    뷰에서 미리 속성을 계산해놓고 필요할 때 렌더링하자.
    뷰 인스턴스에서 computed 속성을 만들어서 그 안에
    메소드를 미리 만들어 두면 된다.

ES6 에 기반한 함수 짜는법 (ES5와 비교)

    ES5

        tasks.filter(function (task) {
            return ! task.completed;
        })

    ES6

        tasks.filter(task => ! task.completed);


캐쉬에 남아있는 경우? 새로고침해야 바뀌는 경우. -> Immediately return 방식

캐쉬에 남아있던 말던 바로 반영되는 경우 -> Reactive 방식

* 뷰를 이용하면 얼마나 다이나믹하고(동적이고) 쉬운지 알 수 있다!

-------------------------------------

components

    1.우선 main.js 를 만들자.

    2. Vue.component('task', {

        template:'<li>foobar</li>

        }) 를 입력하자.

    어디서든 쓸 수 있는 글로벌 뷰 컴포넌트가 생성되었다.

    3. new Vue({

        el:'#root'

        }

        도 입력해주자.


    4. index.html 에서 id가 root 인 div 태그를 만들어놨었다고 가정하고
        그 안에 <task></task> 를 써보자.
        설정해둔 글로벌 뷰 컴포넌트가 나타나는 것을 확인할 수 있다.


* Vue.component('task', {

        template:'<li><slot></slot></li>

        })

        으로 바꿔주면 슬롯 부분이 HTML에서 태그 안에
        적는 텍스트 부분임을 의미한다.

        즉 뷰 컴포넌트에 슬롯을 추가한 상태에서 index.html에
        <task>텍스트</task> 쓰면 화면상에는 <li>텍스트</li>를
        출력한다는 것.

뷰 컴포넌트를 사용하면 이름을 줄 수 있고
탬플릿을 줄 수 있고 data도 줄 수 있음.

* 컴포넌트는 싱글 인스턴스와 연결되어 있지 않으므로
    데이터를 함수로 해서 오브젝트를 return 해주어야 한다.

----------------------------------------------------

뷰 컴포넌트의 기본 구조 예시

    HTML

        <task-list></task-list>


    main.js

        Vue.component('task-list', {

            template: '

                <div>

                    <task v-for="task in tasks'>{{ task.task }}</tesk>

                </div>

            ',

            data() {

                return {

                    tasks [

                        { task: 'Go to the store', complete: true },

                        { task: 'Go to the email', complete: false },

                        { task: 'Go to the farm', complete: true },

                        { task: 'Go to work', complete: false }

                    ]

                };

            }

        });


        Vue.componet('task', {
            template '<li><slot></slot></li>'
        });

        new Vue((

            el: '#root'

        ));



-----------------------------------------------------

선언적 렌더링

 Vue.js의 핵심은 간단한 탬플릿 구문을 사용해 선언적으로 DOM에 데이터를 렌더링하는 것입니다.


    <div id="app">
        {{ message }}
    </div>

    var app = new Vue({
        el: '#app',
        data: {
            message: '안녕하세요 Vue!'
        }
    })

-----------------------------------------------------

Vue는 입력과 앱 상태를 양방향으로 바인딩하는 v-model 디렉티브를 제공합니다.

--------------------------------------------------------


사용자 입력 핸들링

    사용자가 앱과 상호 작용할 수 있게 하기 위해 우리는 v-on 디렉티브를 사용하여 Vue 인스턴스에 메소드를 호출하는 이벤트 리스너를 첨부 할 수 있습니다 :

    <div id="app-5">
        <p>{{ message }}</p>
    <button v-on:click="reverseMessage">메시지 뒤집기</button>
    </div>

    var app5 = new Vue({
        el: '#app-5',
        data: {
        message: '안녕하세요! Vue.js!'
    },

    methods: {
            reverseMessage: function () {
                this.message = this.message.split('').reverse().join('')
            }
        }
    })

------------------------------------------------------

컴포넌트를 사용한 작성방법

Vue에서, 컴포넌트는 본질적으로 미리 정의된 옵션을 가진 Vue 인스턴스 입니다. Vue에서 컴포넌트를 등록하는 방법은 간단합니다.

    // todo-item 이름을 가진 컴포넌트를 정의합니다
    Vue.component('todo-item', {
     template: '<li>할일 항목 하나입니다.</li>'
    })

    이제 다른 컴포넌트의 템플릿에서 이 컴포넌트를 사용할 수 있습니다.

    <ol>
     <!-- todo-item 컴포넌트의 인스턴스 만들기 -->
     <todo-item></todo-item>
    </ol>

-------------------------------------------------------

* 컴포넌트를 사용하여 부모 영역의 데이터를 자식 컴포넌트에 집어넣을 수 있다.

    대규모 응용 프로그램에서는 개발 과정을 관리할 수 있는 수준 하에 두기 위해 전체 앱을 컴포넌트로 나누는 것이 필수적입니다.

    자식 앱인 컴포넌트를 이용하여 부모 앱인 뷰 인스턴스에 영향을 주지 않으면서 개발이 가능합니다.


* 컴포넌트를 사용한 앱의 모습이 어떻게 구성될지에 대한 (상상의) 예를 제시하겠습니다.

<div id="app">
  <app-nav></app-nav>
  <app-view>
    <app-sidebar></app-sidebar>
    <app-content></app-content>
  </app-view>
</div>

즉 Vue.js를 이용하여 프론트앤드 단에서도 부품, 모듈화를 시켜서 작성이 가능하다는 것.

---------------------------------------------------------

* 모든 Vue 컴포넌트는 본질적으로 Vue 인스턴스로부터 확장된 것임을 알아야 합니다.

    Root instance 를 통해 확장된 컴포넌트로 구성되어 있다.

    아래는 뷰 앱 구조 예시이다.

    ex) Root Instance ( 루트 뷰 인스턴스. 컴포넌트 입장에서는 부모이다. )
        └─ TodoList ( 아래부터는 확장된 뷰 루트 인스턴스의 자식 컴포넌트들을 의미한다. )
            ├─ TodoItem
            │  ├─ DeleteTodoButton
            │  └─ EditTodoButton
            └─ TodoListFooter
                ├─ ClearTodosButton
                └─ TodoListStatistics

---------------------------------------------------------

Proxy, 프록시 란?

    Proxy는 일반적으로 대리자/대리인을 의미하며 말 그대로 작업을 대신 수행하거나 중개해주는 역할을 하는 객체를 의미합니다.

    기존 소스를 수정하지 않고 객체의 행동을 다양한 방식으로 제어할 수 있기 때문에, Proxy 패턴은 현대 프레임워크에서 매우 중요한 역할을 담당합니다.

---------------------------------------------------------

자바스크립트 토막지식

* Object.freeze() 메서드는 객체를 얼려 버립니다.  얼려 버린다는 것은 객체에 새로운 속성(property)를 추가할 수 없고,
  객체에 원래 존재하던 속성을 제거할 수 없으며, 객체의 속성, 열거가능성(enumerability), 설정가능성(configurability),
  값 쓰기 가능성(writability)을 변경할 수 없게 만든다는 것을 의미합니다. Object.freeze() 메서드는 결국 객체를 불변(immutable) 객체로 만들어 줍니다.
  Object.freeze() 메서드는 얼려진, 즉, 불변화 된 객체를 반환합니다.

--------------------------------------------

Mustache - 수많은 언어에서 지원되는 초간단 탬플릿 문법 (예 : Angular, Vue.js)

    콧수염처럼 생겨서 머스타치

    {{ }}

--------------------------------------------

자바스크립트 토막지식 - 이벤트 버블링

    https://hyunseob.github.io/2015/08/01/bind-same-event/ 참고

-----------------------------------

* Vue.js는 모든 데이터 바인딩 내에서 JavaScript 표현식의 모든 기능을 지원합니다.

    - 표현식은 Vue 인스턴스 데이터 범위 내에서 JavaScript로 계산됩니다. 한가지 제한사항은 각 바인딩에 하나의 단일 표현식 만 포함될 수 있으므로 아래처럼 작성하면 안됩니다

        <!-- 아래는 구문입니다, 표현식이 아닙니다. -->
        {{ var a = 1 }}

        <!-- 조건문은 작동하지 않습니다. 삼항 연산자를 사용해야 합니다. -->
        {{ if (ok) { return message } }}

    각 바인딩에 하나의 단일 표현식만 포함될 수 있다는 점을 꼭 기억하도록 하자!


    * 템플릿 표현식은 샌드박스(보호된 영역에서 동작) 처리되며 Math와 Date 같은 전역으로 사용 가능한 것에만 접근할 수 있습니다. 템플릿 표현식에서 사용자 정의 전역에 액세스 하지 마십시오.

------------------------------------

샌드박스(Sandbox) 기술이란?

    샌드박스란 미국에서 어린아이를 보호하기 위해 모래통(Sandbox)에서만 놀도록 하는데서 유래한 보안 모델을 말합니다.

    즉, 외부 접근 및 영향을 차단하여 제한된 영역 내에서만 프로그램을 동작시키는 것입니다.
    샌드박스 내에서 어떤 파일이나 프로세스가 안전하지 못하다고 판명되면, 외부로의 접근을 차단하여 시스템에 피해를 입히는 것을 방지합니다.

    예를 들어 악성 프로그램이나 악성코드의 경우, 본래의 공격행위를 하더라도 실제 시스템 내 파일이나 프로세스를 감염시킬 수 없습니다.
    이러한 특징들로 말미암아 가상화를 통한 보안으로서 악성코드를 감지하고 분석하는데 사용되는 기술입니다.

    그러나 샌드박스 기술이 기존 시그니처 기반 탐지의 한계를 극복하는 대안으로 각광받자, 해커들은 샌드박스를 탐지 및 우회하는 악성코드를 만들어 냈습니다.
    악성코드가 동작하는 환경이 샌드박스로 감지되면 C&C 주소를 숨기거나 다른 HTTP 리퀘스트를 사용하여 보안업체로 하여금 악성코드를 분석하는 것을 방해합니다.
    혹은 해당 환경설정이나 IP주소를 수집하여 C&C서버로 전송하는 등 분석을 시도하는 보안업체의 정보를 파악하는 지능형 악성코드 군도 존재합니다.

    샌드박스 기술이 APT공격의 주요 보안 솔루션이지만, 이를 우회하는 악성코드가 존재하는데다가 가상화 공간에서 동작을 수행하는데 시간이 다소 걸린다는 단점도 있습니다.
    이러한 이유로 샌드박스 기술은 기존 보안 솔루션들을 보완하는 차원에서 통합으로 사용되는 경우도 있습니다.

-------------------------------------

* 보안 관련 이슈들 배경지식 참고

    https://www.estsecurity.com/securityCenter/commonSense/1?

-------------------------------------

프로그래밍 용어

Side Effect 란?

    변화가 일어나는 행위.

    쉽게 말해서 실행 중에 어떤 객체를 접근해서 변화가 일어나는 행위(라이브러리 I/O, 객체 변경 등)입니다.

    예제를 한 번 보겠습니다.

    x = 3 + 4;
    위의 표현식은 1개의 side effect가 있습니다. x의 값이 변경되었기 때문입니다. .

    y = x++;
    위의 표현식은 총 2개의 side effect가 있습니다. x++에서 x가 한 번 변하고, x 값 대입으로 y가 한 번 변합니다.

    3 + 4;
    위 표현식은 side effect가 없습니다.

    if(flag){
        foo();
    }
    위 표현식은 flag가 true일 경우에 한해서 잠재적으로 side effect 가 있습니다.

    예시)

        sizeof 에서 잘못 사용
            sizeof는 보통 어떤 변수나 타입의 크기를 알아낼 때 사용됩니다. 하지만 종종 아래와 같이 sizeof 안에 side effect를 일으키는 연산을 적는 경우가 있습니다.

            int a = 14;
            int b = sizeof(a++);

            안전하게 사용하려면 sizeof 에는 어떠한 side effect도 일어나지 않도록 프로그래밍 해야 합니다.

------------------------------------------

디렉티브

    디렉티브는 v- 접두사가 있는 특수 속성입니다. 디렉티브 속성 값은 단일 JavaScript 표현식 이 됩니다. (나중에 설명할 v-for는 예외입니다.)
    디렉티브의 역할은 표현식의 값이 변경될 때 사이드이펙트를 반응적으로 DOM에 적용하는 것 입니다. 아래 예제에서 살펴보겠습니다.

    ex)

        <p v-if="seen">이제 나를 볼 수 있어요</p>

        여기서, v-if 디렉티브는 seen 표현의 진실성에 기반하여 <p> 엘리먼트를 제거 또는 삽입합니다.

-------------------------------------------

수식어

    수식어는 점으로 표시되는 특수 접미사로, 디렉티브를 특별한 방법으로 바인딩 해야 함을 나타냅니다.
    예를 들어, .prevent 수식어는 트리거된 이벤트에서 event.preventDefault()를 호출하도록 v-on 디렉티브에게 알려줍니다.

<form v-on:submit.prevent="onSubmit"> 내용 </form>

나중에 v-on과 v-model을 더 자세히 살펴볼 때 수식어를 더 많이 사용할 것 입니다.

-----------------------------------------------

약어

    v- 접두사는 템플릿의 Vue 특정 속성을 식별하기 위한 시각적인 신호 역할을 합니다.
    이 기능은 Vue.js를 사용하여 기존의 마크업에 동적인 동작을 적용할 때 유용하지만 일부 자주 사용되는 디렉티브에 대해 너무 장황하다고 느껴질 수 있습니다.
    동시에 Vue.js가 모든 템플릿을 관리하는 SPA를 만들 때 v- 접두어의 필요성이 떨어집니다.
    따라서 가장 자주 사용되는 두개의 디렉티브인 v-bind와 v-on에 대해 특별한 약어를 제공합니다.

    SPA 란? Single-page application 을 의미한다.

    v-bind 약어

        <!-- 전체 문법 -->
        <a v-bind:href="url"> ... </a>

        <!-- 약어 -->
        <a :href="url"> ... </a>

    v-on 약어

        <!-- 전체 문법 -->
        <a v-on:click="doSomething"> ... </a>

        <!-- 약어 -->
        <a @click="doSomething"> ... </a>

    이들은 일반적인 HTML과 조금 다르게 보일 수 있습니다. 하지만 :와 @는 속성 이름에 유효한 문자이며 Vue.js를 지원하는 모든 브라우저는 올바르게 구문 분석을 할 수 있습니다.
    또한 최종 렌더링 된 마크업에는 나타나지 않습니다. 약어는 완전히 선택사항이지만 나중에 익숙해지면 편할 것 입니다.

    * 자주 사용하는 v-on 이나 v-bind 인 경우 약어를 사용할 수 있게 되어있다!

---------------------------------------------------

Vue.js가 말하는 AngularJS와 뷰JS의 차이점


AngularJS (Angular 1)

        일부 Vue의 문법은 Angular와 매우 유사합니다 (예 :v-if와ng-if). Angular가 제대로 된 많은 것들을 가지고 있었기 때문에 이것은 개발 초기에 Vue에게 영감이 되었습니다.
        Angular와 함께 제공되는 많은 고통이 있었지만 Vue가 상당한 개선을 제공하려고 시도하였습니다.

    복잡도

        Vue는 API와 디자인면에서 Angular 1보다 훨씬 간단합니다. 평범하지 않은 애플리케이션을 작성하기에 충분한 학습기간은 일반적으로 1 일 미만으로 소요되며 Angular 1에서는 그렇지 않습니다.

    유연성과 모듈성

        Angular는 애플리케이션을 어떻게 구성해야 하는지에 대한 강요가 강하고 Vue는 더욱 유연하고 모듈방식의 솔루션입니다. 이로 인해 Vue는 다양한 프로젝트에보다 적합하게 적용될 수 있으며,
        때로는 코딩을 시작하기 위해 의사 결정을 내리는데 유용 할 때가 있습니다.

        그렇기 때문에 핫 모듈 리로딩, 린트 (linting), CSS 추출과 같은 고급 기능에 대한 액세스 권한을 부여하는 동시에 빠르게 설정할 수있는 Webpack 템플릿을 제공합니다.

    데이터 바인딩

        Angular 1은 스코프간 양방향 바인딩을 사용하는 반면 Vue는 컴포넌트 간에 단방향의 데이터 흐름을 사용합니다. 이로 인해 데이터의 흐름이 단순한 애플리케이션에서는 데이터의 흐름을 쉽게 파악할 수 있습니다.

    디렉티브 vs 컴포넌트

        Vue는 디렉티브와 컴포넌트를 명확하게 구분합니다. 지시어는 DOM 조작만 캡슐화 하기 위한 것이고 컴포넌트는 자체 뷰와 데이터 로직이 있는 자체의 포함 단위입니다. Angular에서는 이 둘 사이에 많은 혼란이 있습니다.


그렇다면 Vue.js 최신 Angular 와의 차이점은?

    Angular (Formerly known as Angular 2)

        Angular 2는 완전히 새로운 것이기 때문에 별도의 섹션을 만들었습니다. 예를 들어, 1급 컴포넌트 시스템이 있으며 많은 구현 세부 사항이 완전히 다시 작성 되었으며 API도 상당히 크게 변경되었습니다.


    TypeScript

        Angular는 TypeScript가 필수적입니다. 문서 또한 TypeScript 기반입니다. TypeScript를 사용하면 Java와 C#을 다루던 사용자에게 생산성을 올려주고 정적 타입 체크 등의 많은 이익이 있습니다.
        그러나 모든 사람들이 TypeScript를 사용하려고 하지는 않습니다.

        많은 소규모 사례에서 TypeScript를 사용하면 생산성 향상보다 더 많은 오버헤드가 발생할 수 있습니다.
        이 경우 TypeScript 없이 Angular를 사용하는 것이 어려울 수 있기 때문에 Vue를 사용하는 것이 좋습니다.

        Vue는 엔터프라이즈 환경에도 매우 적합하며 공식 Typings 및 공식 decorator를 통해 TypeScript와 함께 사용할 수도 있습니다.

    학습 곡선

        Vue를 시작하려면 HTML 및 ES5 JavaScript (즉, 일반 자바 스크립트)에 익숙해야합니다. 이러한 기본 기술을 사용하면 안내서를 읽는 하루 만에 작은 애플리케이션을 작성할 수 있습니다.

        Angular의 학습곡선은 훨씬 가파릅니다. 프레임워크 API는 방대하며 생산성이 올라가기 전에 매우 많은 것들을 알아야합니다.
        Angular의 복잡성은 대규모 앱을 목표로 합니다. 하지만 경험이 부족한 개발자가 선택하기에 훨씬 어렵습니다.

----------------------------------------------------

vue와 ajax 요청

 * Axios 를 이용한 HTTP 요청

        vue에서 ajax 요청을 하는 방법은 여러가지가 있습니다. 순수 자바스크립트, jQuery를 사용하여 작업할 수도 있고, vue-resource와 axios도 있습니다. 이번에는 axios를 사용하는 방법을 소개 합니다.

    왜 vue-resource를 사용하지 않나요?

        vue-resource는 현재(2017년 1월) github에서 3600여개의 스타를 받은 성공적인 프로젝트 입니다.
        vue와 함께 잘 작동합니다. 하지만, 2016년 9월 이후 업데이트가 되지 않고 있습니다. 해결되지 않은 이슈가 무려 100여개가 넘습니다.
        그리고 결정적으로 vue의 Evan You는 자신의 Medium에서 공식적으로 추천하는 프로젝트가 아니라고 말합니다. 자세한 내용은 이 글을 확인하세요.

    axios를 사용하세요

        axios는 현재 가장 성공적인 HTTP 클라이언트 라이브러리 중 하나입니다. 아직 1.x 버전이 릴리즈 되지 않았지만 스타가 1만개가 넘을 정도로 인기가 좋습니다.
        특별히 언급할만한 부분은 요청 취소와 TypeScript를 사용할 수 있는 것 입니다. 이 글에서는 기본적인 vue와 axios의 사용 방법을 알아봅니다.
        axios의 github 프로젝트를 살펴보시면 더 많은 내용을 익힐 수 있을 것입니다.

    axios 설치

        vue-cli를 사용하고 계신다면 간단하게 추가할 수있습니다. vue-cli에 대한 간략한 설명은 vue.js 한국어 사용자 모임의 한국어 번역을 확인하세요.
        터미널에서 npm 명령어를 이용하여 설치합니다.


 * Lodash 라이브러리 이용

    underscore보다 성능이 좋다고 알려져 있다. 함수형 프로그래밍을 지원할 수 있는 유용한 JavaScript Library이다.
    (개인적인 의견으로 현재시점에서 ES6를 사용함에 있어서 이게 쓰이는지는 확실하지 않음.)
    Ajax 관련해서 제공하는 기능도 있나보다. 내가 모르는 여러 기능이 있는듯.

    아래는 제공하는 기능(함수) 예시이다.

        _.debounce  시간이 많이 소요되는 작업을 실행할 수 있는 빈도를 제한한다.

------------------------------------------------------------------

계산된 캐싱 vs 메소드

    표현식에서 메소드를 호출하여 같은 결과를 얻을 수 있다는 사실을 알고 있을 것입니다.

    <p>뒤집힌 메시지: "{{ reversedMessage() }}"</p>
    // 컴포넌트 내부
    methods: {
        reversedMessage: function () {
            return this.message.split('').reverse().join('')
        }
    }

    계산된 속성 대신 메소드와 같은 함수를 정의할 수 있습니다. 최종 결과에 대해 두가지 접근 방식은 서로 동일합니다.
    하지만 차이점은 계산된 속성은 종속성에 따라 캐시된다는 것 입니다. 계산된 속성은 종속성 중 일부가 변경된 경우에만 다시 계산 됩니다.
    이것은 message가 변경되지 않는 한, 계산된 속성인 reversedMessage에 대한 다중 접근은 함수를 다시 수행할 필요 없이 이전에 계산된 결과를 즉시 반환한다는 것을 의미합니다.

    이것은 또한 Date.now()가 반응형 의존성을 가지지 않기 때문에 다음 계산된 속성이 절대로 업데이트 되지 않는 것을 의미합니다.

    computed: {
        now: function () {
            return Date.now()
        }
    }

    비교해보면, 메소드 호출은 재 렌더링 할 때마다 항상 메소드를 호출합니다.

    캐싱이 왜 필요할까요? 우리가 시간이 많이 소요되는 A 속성을 가지고 있다고 가정하면 거대한 배열을 반복하고 많은 계산을 해야합니다.
    그런 다음 우리는 A 에 의존하는 다른 계산된 속성을 가질 수 있습니다. 캐싱하지 않으면 A 의 getter를 필요한 것보다 더 많이 실행하게 됩니다!
    캐싱을 원하지 않는 경우 메소드를 사용하십시오. ( 캐싱을 이용하면 브라우저를 추후 빠르게 불러올 수 있음 )

----------------------------------------------------------------------------

계산된 속성 vs 감시된 속성

    Vue는 Vue 인스턴스의 데이터 변경을 관찰하고 이에 반응하는 보다 일반적인 속성 감시 방법을 제공합니다. 다른 데이터 기반으로 변경할 필요가 있는 데이터가 있는 경우,
    특히 AngularJS를 사용하던 경우 watch를 남용하는 경우가 있습니다. 하지만 watch 콜백보다 계산된 속성을 사용하는 것이 더 좋습니다. 다음 예제를 고려하십시오.

    <div id="demo">{{ fullName }}</div>
    var vm = new Vue({
    el: '#demo',
    data: {
        firstName: 'Foo',
        lastName: 'Bar',
        fullName: 'Foo Bar'
    },
    watch: {
        firstName: function (val) {
        this.fullName = val + ' ' + this.lastName
        },
        lastName: function (val) {
        this.fullName = this.firstName + ' ' + val
            }
    }
    })

    위의 코드는 반복이 필수적입니다. 계산된 속성을 사용하는 방식과 비교하십시오.

    var vm = new Vue({
    el: '#demo',
    data: {
        firstName: 'Foo',
        lastName: 'Bar'
    },
    computed: {
        fullName: function () {
        return this.firstName + ' ' + this.lastName
        }
    }
    })

    더 낫지 않나요?

-------------------------------------------------------------------------------------

계산된 Setter

    계산된 속성은 기본적으로 getter만 가지고 있지만, 필요한 경우 setter를 제공할 수 있습니다.

    // ...
    computed: {
    fullName: {
        // getter
        get: function () {
            return this.firstName + ' ' + this.lastName
        },
        // setter
        set: function (newValue) {
            var names = newValue.split(' ')
            this.firstName = names[0]
            this.lastName = names[names.length - 1]
        }
      }
    }
    // ...

    이제 vm.fullName = 'John Doe'를 실행하면 설정자가 호출되고 vm.firstName과 vm.lastName이 그에 따라 업데이트 됩니다.

----------------------------------------------------------------------------------------

감시자

    대부분의 경우 계산된 속성이 더 적합하지만 사용자 정의 감시자가 필요한 경우가 있습니다. 그래서 Vue는 watch 옵션을 통해 데이터 변경에 반응하는 보다 일반적인 방법을 제공합니다.
    이는 데이터 변경에 대한 응답으로 비동기식 또는 시간이 많이 소요되는 조작을 수행하려는 경우에 가장 유용합니다.

    예시

    var watchExampleVM = new Vue({
        el: '#watch-example',
        data: {
            question: '',
            answer: '질문을 하기 전까지는 대답할 수 없습니다.'
        },

    watch: {
        // 질문이 변경될 때 마다 이 기능이 실행됩니다.

        question: function (newQuestion) {
          this.answer = '입력을 기다리는 중...'
            this.getAnswer()
        }
    },
    methods: { ...로직... }
    })

------------------------------------------------------------------------

Key를 이용한 재사용 가능한 엘리먼트 제어

    Vue는 가능한 한 효율적으로 엘리먼트를 렌더링하려고 시도하며 종종 처음부터 렌더링을 하지않고 다시 사용합니다. Vue를 매우 빠르게 만드는데 도움이 되는 것 이외에 몇가지 유용한 이점이 있습니다.
    예를 들어 사용자가 여러 로그인 유형을 트랜지션할 수 있도록 허용하는 경우입니다.

    <template v-if="loginType === 'username'">
        <label>사용자 이름</label>
        <input placeholder="사용자 이름을 입력하세요">
    </template>
    <template v-else>
        <label>이메일</label>
        <input placeholder="이메일 주소를 입력하세요">
    </template>

    위 코드에서 loginType을 바꾸어도 사용자가 이미 입력한 내용은 지워지지 않습니다. 두 템플릿 모두 같은 요소를 사용하므로 <input>은 대체되지 않고 단지 placeholder만 변경됩니다.

    폼 인풋에 텍스트를 입력하고 토글 버튼을 눌러 직접 확인하십시오.

    이것은 항상 바람직하지는 않습니다. 때문에 “이 두 엘리먼트는 완전히 별개이므로 다시 사용하지 마십시오.”라고 알리는 방법을 제공합니다. 유일한 값으로 key 속성을 추가하십시오.

    <template v-if="loginType === 'username'">
        <label>사용자 이름</label>
        <input placeholder="사용자 이름을 입력하세요" key="username-input">
    </template>
    <template v-else>
        <label>이메일</label>
        <input placeholder="이메일 주소를 입력하세요" key="email-input">
    </template>

    이제 트랜지션 할 때마다 입력이 처음부터 렌더링됩니다. 직접 확인해보세요.

    <label> 엘리먼트는 key 속성이 없기 때문에 여전히 효율적으로 재사용 됩니다.

----------------------------------------------------------------------------

v-show

    엘리먼트를 조건부로 표시하기 위한 또 다른 옵션은 v-show 디렉티브입니다. 사용법은 거의 동일합니다.

<h1 v-show="ok">안녕하세요!</h1>

차이점은 v-show가 있는 엘리먼트는 항상 렌더링 되고 DOM에 남아있다는 점입니다. v-show는 단순히 엘리먼트에 display CSS 속성을 토글합니다.

    * v-show는 <template> 구문을 지원하지 않으며 v-else와도 작동하지 않습니다.

-----------------------------------------------------------------------------

v-if vs v-show

    v-if는 조건부 블럭 안의 이벤트 리스너와 자식 컴포넌트가 토글하는 동안 적절하게 제거되고 다시 만들어지기 때문에 “진짜” 조건부 렌더링 입니다

    v-if는 또한 게으릅니다 초기 렌더링에서 조건이 거짓인 경우 아무것도 하지 않습니다. 조건 블록이 처음으로 참이 될 때 까지 렌더링 되지 않습니다.

    비교해보면, v-show는 훨씬 단순합니다. CSS 기반 토글만으로 초기 조건에 관계 없이 엘리먼트가 항상 렌더링 됩니다.

    일반적으로 v-if는 토글 비용이 높고 v-show는 초기 렌더링 비용이 더 높습니다. 매우 자주 바꾸기를 원한다면 v-show를, 런타임 시 조건이 바뀌지 않으면 v-if를 권장합니다.

----------------------------------------------------------------------------

v-if 와 v-for

    v-if와 함께 사용하는 경우, v-for는 v-if보다 높은 우선순위를 갖습니다.

------------------------------------------------------------------------------

v-for와 객체

    v-for를 사용하여 객체의 속성을 반복할 수도 있습니다.

    <ul id="v-for-object" class="demo">
        <li v-for="value in object">
            {{ value }}
        </li>
    </ul>

    new Vue({
        el: '#v-for-object',
        data: {
        object: {
            firstName: 'John',
            lastName: 'Doe',
            age: 30
            }
        }
    })


    키의 두번째 전달 인자를 제공할 수도 있습니다.

    <div v-for="(value, key) in object">
        {{ key }}: {{ value }}
    </div>

    그리고 또 인덱스도 제공합니다

    <div v-for="(value, key, index) in object">
        {{ index }}. {{ key }} : {{ value }}
    </div>

* Vue가 각 노드의 ID를 추적하고 기존 엘리먼트를 재사용하고 재정렬할 수 있도록 힌트를 제공하려면 각 항목에 고유한 key 속성을 제공해야 합니다. key에 대한 이상적인 값은 각 항목의 고유한 ID입니다.
  반복되는 DOM 내용이 단순하지 않거나 의도적인 성능 향상을 위해 기본 동작에 의존하지 않는한 가능하면 언제나 v-for에 key를 추가하는 것이 좋습니다.
  key는 Vue가 노드를 식별하는 일반적인 메커니즘이기 때문에 v-for에 특별히 연관되지 않은 다른 용도로 사용합니다.

---------------------------------------------------------

Queue 큐 - 선입 선출 FIFO


자바스크립트 메서드 참고

splice 메서드(Array)(JavaScript)

    배열에서 요소를 제거하고, 필요하면 그 자리에 새 요소를 삽입한 다음 삭제된 요소를 반환합니다.

slice()

    슬라이스 함수에서 마이너스는 뒤에부터 표기되는 것을 의미한다.

     slice(start,end) end는 불포함.

pop() 메서드는 배열의 마지막 원소를 제거하고 배열의 길이를 감소시킨 후 배열에서 제거한 원소를 반환한다.

push() 메서드는 하나 혹은 그 이상의 원소들을 배열의 끝 부분에 이어 붙이고 배열의 새로운 길이를 반환한다.

위 메서드를 사용하면 배열을 마치 스택인 것처럼 조작할 수 있다.

unshift() & shift()

    push(), pop()과 유사하며 이 메서들은 배열의 끝이 아니라 배열의 맨 앞에 원소를 삽입하고 제거한다.


----------------------------------------------------------------------------


포커스 이벤트

- 요소(링크나 폼 필드)가 포커스를 얻거나 잃을 때 발생한다.

focus	요소가 포커스를 얻었을 때 (거품을 생성하지 않음).
blur	요소가 포커스를 잃었을 때 (거품을 내지 않습니다).

------------------------------------------------------------------------------

* v-on 디렉티브를 사용하여 DOM 이벤트를 듣고 트리거 될 때 JavaScript를 실행할 수 있습니다.

-------------------------------------------------------------------------------

주의 사항

    JavaScript의 제한으로 인해 Vue는 배열에 대해 다음과 같은 변경 사항을 감지할 수 없습니다.

    1. 인덱스로 배열에 있는 항목을 직접 설정하는 경우, 예: vm.items[indexOfItem] = newValue
    2. 배열 길이를 수정하는 경우, 예: vm.items.length = newLength

    주의 사항 중 1번을 극복하기 위해 다음 두 경우 모두 vm.items[indexOfItem] = newValue 와 동일하게 수행하며, 반응형 시스템에서도 상태 변경을 트리거 합니다.

    // Vue.set
    Vue.set(example1.items, indexOfItem, newValue)

    // Array.prototype.splice
    example1.items.splice(indexOfItem, 1, newValue)

    주의 사항 중 2번을 극복하기 위해 splice를 사용해야 합니다.

    example1.items.splice(newLength) // newLength 인덱스포함하여 모두제거 -> newLength 만큼의 배열 길이가 만들어짐

-----------------------------------------------------------------------------------

객체 변경 감지에 관한 주의사항

    모던 JavaScript의 한계로 Vue는 속성 추가 및 삭제를 감지하지 못합니다. 예를들어,

    var vm = new Vue({
        data: {
          a: 1
        }
    })
    // `vm.a` 는 반응형입니다.

    vm.b = 2
    // `vm.b` 는 반응형이 아닙니다.

    Vue는 이미 만들어진 인스턴스에 새로운 루트레벨의 반응형 속성을 동적으로 추가하는 것을 허용하지 않습니다.
    그러나 Vue.set(object, key, value) 메소드를 사용하여 중첩된 객체에 반응형 속성을 추가할 수 있습니다.

    var vm = new Vue({
        data: {
            userProfile: {
                name: 'Anika'
            }
        }
    })

    다음과 같이 중첩된 userProfile 객체에 새로운 속성 age를 추가합니다.

    Vue.set(vm.userProfile, 'age', 27)
    인스턴스 메소드인 vm.$set를 사용할 수도 있습니다. 이는 전역 Vue.set의 별칭입니다.

    vm.$set(this.userProfile, 'age', 27)
    때로는 Object.assign()이나 _.extend()를 사용해 기존의 객체에 새 속성을 할당할 수 있습니다. 이 경우 두 객체의 속성을 사용해 새 객체를 만들어야 합니다.

    Object.assign(this.userProfile, {
        age: 27,
        favoriteColor: 'Vue Green'
    })

    새로운 반응형 속성을 다음과 같이 추가합니다.

    this.userProfile = Object.assign({}, this.userProfile, {
        age: 27,
        favoriteColor: 'Vue Green'
    })

---------------------------------------------------

v-for 와 컴포넌트

    이 섹션에서는 컴포넌트를 안다고 가정합니다. 부담없이 건너뛰어도 됩니다.

    v-for를 사용자 정의 컴포넌트에 직접 사용할 수 있습니다.

    <my-component v-for="item in items" :key="item.id"></my-component>
    2.2.0 이상에서 v-for는 key 가 필수 입니다.

    그러나 컴포넌트에는 자체 범위가 분리되어있기 때문에 컴포넌트에 데이터를 자동으로 전달하지는 않습니다. 반복할 데이터를 컴포넌트로 전달하려면 props도 사용해야합니다.

    <my-component
        v-for="(item, index) in items"
        v-bind:item="item"
        v-bind:index="index"
        v-bind:key="item.id"
    ></my-component>

컴포넌트에 item을 자동으로 주입하지 않는 이유는 컴포넌트가 v-for의 작동 방식과 밀접하게 결합되기 때문입니다. 데이터의 출처를 명확히 하면 다른 상황에서 컴포넌트를 재사용할 수 있습니다.


-----------------------------------------------------

이벤트가 자바스크립트를 실행하는 방법

    사용자가 웹 페이지의 HTML과 상호작용할 때 다음과 같은 세 단계를 거쳐 자바스크립트 코드가 실행된다.
    이 단계를 이벤트 핸들링(Event Handling)이라고 한다.

1. 이벤트에 반응할 스크립트를 실행할 요소를 선택한다.

    - 해당노드에 접근하기 위해 DOM 쿼리를 이용한다.

2. 선택된 노드에서 어떤 이벤트가 발생했을 떄 그에 반응할 것인지를 명시한다.

    - 개발자들은 이를 DOM 노드에 이벤트를 바인딩(binding)한다고 표현한다.

3. 이벤트가 발생했을 때 실행될 코드를 작성한다.

    - 특성 요소에서 이벤트가 발생하면 이 이벤트는 함수를 실행한다. 이 함수는 이름을 가진 함수일 수도 있고,
      이름을 가지지 않은 익명 함수일 수도 있다.


자바스크립트에서 요소에 이벤트를 바인딩하는 3가지 방법

    1. HTML을 이용한 인라인 방식

    2. DOM 이벤트 핸들러의 활용. (DOM 쿼리를 이용하여 뒤에 이벤트를 붙임. ex) el.onblur 이 때 el은 조회한 노드를 담은 변수이다.)
        한 이벤트 핸들러에 하나의 함수만 바인딩 가능.

    3. 이벤트 리스너. 이벤트를 처리하는 가장 최신 기법. 한 이벤트에 대해 하나 이상의 함수를 지정할 수도 있지만 오래된 브라우저에서는 지원 x

* 이벤트 요약

이벤트는 브라우저가 어떤 일이 발생했음을 알리는 수단이다.
* 바인딩은 어떤 요소에서 어떤 이벤트가 발생했을 때, 어떻게 처리할 것인지를 정의하는 과정이다.
요소에서 이벤트가 발생하면 자바스크립트 함수가 호출된다. 이 함수가 웹 페이지에 어떤 식으로든
변경을 가해, 사용자의 행동에 반응을 보임으로써 인터랙티브한 느낌을 준다.
이벤트 전파를 이용하여 특정 요소의 모든 자식 요소에서 발생한 이벤트를 모니터링할 수 있다.
HTML5 명세에 정의된 이벤트나 브라우저 종속적인 이벤트들도 있지만, 가장 빈번하게 사용되는 이벤트는 W3C DOM 이벤트들이다.

---------------------------------------------------------------------------

이벤트 핸들링

    이벤트 청취

        v-on 디렉티브를 사용하여 DOM 이벤트를 듣고 트리거 될 때 JavaScript를 실행할 수 있습니다.

    메소드 이벤트 핸들러

        많은 이벤트 핸들러의 로직은 더 복잡할 것이므로, JavaScript를 v-on 속성 값으로 보관하는 것은 간단하지 않습니다. 이 때문에 v-on이 호출하고자 하는 메소드의 이름을 받는 이유입니다.

        * Vue 인스턴스에서 data로 보관하기보다는 보통 복잡한 로직들이기 때문에 메소드로 쓰인다.

---------------------------------------------------------------------------

event.stopPropagation()

    이벤트 캡쳐링과 버블링에 있어 현재 이벤트 이후의 전파를 막습니다. (이벤트 전파를 막음)
        propagation의 뜻은 (소리 등의)전파, 번식, 증식 을 의미한다.

event.preventDefault()

    이벤트를 취소할 수 있는 경우, 이벤트의 전파를 막지않고 그 이벤트를 취소합니다. (현재 이벤트의 기본 동작을 중단. 전파는 안막아짐.)

* 일반적으로 해당 DOM에서 내가 원하는 이벤트 동작만을 수행하고 싶을 때에는 보통 event.stopPropagation()과
    event.preventDefault() 두 코드를 모두 사용해야 한다.

return false

    제이쿼리 사용시 event.stopPropagation()과 event.preventDefault() 를 모두 수행한 것과 같음
    사용 안할 시 event.preventDefault()와 같다.

--------------------------------------------------------------------------

이벤트 수식어

    이벤트 핸들러 내부에서 event.preventDefault() 또는 event.stopPropagation()를 호출하는 것은 매우 보편적인 일입니다.
    메소드 내에서 쉽게 이 작업을 할 수 있지만, DOM 이벤트 세부 사항을 처리하는 대신 데이터 로직에 대한 메소드만 사용할 수 있으면 더 좋을 것입니다.
    이 문제를 해결하기 위해, Vue는 v-on 이벤트에 이벤트 수식어를 제공합니다. 수식어는 점으로 표시된 접미사 입니다.

.stop
.prevent
.capture
.self
.once

<!-- 클릭 이벤트 전파가 중단됩니다 -->
<a v-on:click.stop="doThis"></a>

<!-- 제출 이벤트가 페이지를 다시 로드 하지 않습니다 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 수식어는 체이닝 가능합니다 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 단순히 수식어만 사용할 수 있습니다 -->
<form v-on:submit.prevent></form>

<!-- 이벤트 리스너를 추가할 때 캡처모드를 사용합니다 -->
<!-- 즉, 내부 엘리먼트를 대상으로 하는 이벤트가 해당 엘리먼트에서 처리되기 전에 여기서 처리합니다. -->
<div v-on:click.capture="doThis">...</div>


<!-- event.target이 엘리먼트 자체인 경우에만 트리거를 처리합니다 -->
<!-- 자식 엘리먼트에서는 안됩니다 -->
<div v-on:click.self="doThat">...</div>

* 관련 코드가 동일한 순서로 생성되므로 수식어를 사용할 때 순서를 지정하세요.
  다시말해 `@click.prevent.self를 사용하면 **모든 클릭**을 막을 수 있으며 @click.self.prevent`는 엘리먼트 자체에 대한 클릭만 방지합니다.

----------------------------------------------------

2.1.4에 새로 추가됨

    <!-- 클릭 이벤트는 최대 한번만 트리거 됩니다. -->
    <a v-on:click.once="doThis"></a>

 네이티브 DOM 이벤트에 독점적인 다른 수식어와 달리,.once 수식어는 컴포넌트 이벤트에서도 사용할 수 있습니다.

2.3.0+ 이후 추가됨

    <!-- 스크롤의 기본 이벤트를 취소할 수 없습니다. -->
    <div v-on:scroll.passive="onScroll">...</div>

    추가로, Vue는 .passive 수식어를 제공합니다. 특히 모바일 환경에서 성능향상에 도움이 됩니다.
    예를 들어, 브라우저는 핸들러가 event.preventDefault()를 호출할지 알지 못하므로 프로세스가 완료된 후 스크롤 합니다.
    .passive 수식어는 이 이벤트가 기본 동작을 멈추지 않는다는 것을 브라우저에 알릴 수 있습니다.

 .passive와 .prevent를 함께 사용하지 마세요. 패시브 핸들러는 기본 이벤트를 막지 않습니다.

-------------------------------------------------

키 수식어

    키보드 이벤트를 청취할 때, 종종 공통 키 코드를 확인해야 합니다. Vue는 키 이벤트를 수신할 때 v-on에 대한 키 수식어를 추가할 수 있습니다.

    <!-- keyCode가 13일 때만 `vm.submit()`을 호출합니다  -->
    <input v-on:keyup.13="submit">
    keyCode를 모두 기억하는 것은 힘듭니다. 그래서 Vue는 자주 사용하는 키의 알리아스를 제공합니다.

    <!-- 위와 같습니다 -->
    <input v-on:keyup.enter="submit">

    <!-- 약어 사용도 가능합니다 -->
    <input @keyup.enter="submit">
    키 수식어 별칭의 전체 목록입니다.

    .enter
    .tab
    .delete (“Delete” 와 “Backspace” 키 모두를 캡처합니다)
    .esc
    .space
    .up
    .down
    .left
    .right
    또한 전역 config.keyCodes 객체를 통해 사용자 지정 키 수식어 별칭을 지정할 수 있습니다.

    // `v-on:keyup.f1`을 사용할 수 있습니다.
    Vue.config.keyCodes.f1 = 112

---------------------------------------------------

시스템 수식어 키 목록

2.1.0+에서 추가됨

다음 수식어를 사용해 해당 수식어 키가 눌러진 경우에만 마우스 또는 키보드 이벤트 리스너를 트리거 할 수 있습니다.

    .ctrl
    .alt
    .shift
    .meta

참고 : 매킨토시 키보드에서 meta는 command 키 입니다 (⌘). Windows 키보드에서 meta는 windows 키 (⊞) 입니다. Sun Microsystems 키보드에서 meta는 단색의 다이아몬드 (◆)로 표시됩니다.
특정 키보드의 경우, 특히 MIT 및 Lisp 시스템 키보드와 Knight 키보드, space-cadet 키보드와 같은 제품에는 “META” 레이블이 지정됩니다. Symbolics 키보드에서 메타는 “META” 또는 “Meta”로 표시됩니다.

예제:

    <!-- Alt + C -->
    <input @keyup.alt.67="clear">

    <!-- Ctrl + Click -->
    <div @click.ctrl="doSomething">Do something</div>

* 수식어 키는 일반 키와 다르며 keyup 이벤트와 함께 사용되면 이벤트가 발생할 때 수식어 키가 눌려있어야 합니다.
  즉,keyup.ctrl는 ctrl을 누른 상태에서 키를 놓으면 트리거됩니다. ctrl 키만 놓으면 트리거되지 않습니다.

------------------------------------------------------

.exact 수식어
    2.5.0+에서 추가됨

.exact 수식어는 다른 시스템 수식어와 조합해 그 핸들러가 실행되기 위해 정확한 조합이 눌러야하는 것을 보여줍니다.

    <!-- Alt 또는 Shift와 함께 눌린 경우에도 실행됩니다. -->
    <button @click.ctrl="onClick">A</button>

    <!-- Ctrl 키만 눌려있을 때만 실행됩니다. -->
    <button @click.ctrl.exact="onCtrlClick">A</button>

    <!-- 아래 코드는 시스템 키가 눌리지 않은 상태인 경우에만 작동합니다. -->
    <button @click.exact="onClick">A</button>

--------------------------------------------------------

마우스 버튼 수식어
    2.2.0 버전에서 추가됨

    .left
    .right
    .middle

위 수정자는 특정 마우스 버튼에 의해 트리거 된 이벤트로 핸들러를 제한합니다.

---------------------------------------------------------

*** 왜 HTML로 된 리스너를 사용합니까??

이 모든 이벤트 청취 접근 방법이 우려 사항 분리(“separation of concerns”)에 대한 오래된 규칙을 어긴다고 생각할 수 있습니다.
모든 뷰 핸들러 함수와 표현식은 현재 뷰 처리 하는 ViewModel에 엄격히 바인딩 되기 때문에 유지보수가 어렵지 않습니다. 실제로 v-on을 사용하면 몇가지 이점이 있습니다.

1. HTML 템플릿을 간단히 하여 JavaScript 코드 내에서 핸들러 함수 구현을 찾는 것이 더 쉽습니다.

2. JavaScript에서 이벤트 리스너를 수동으로 연결할 필요가 없으므로 ViewModel 코드는 순수 로직과 DOM이 필요하지 않습니다. 이렇게 하면 테스트가 쉬워집니다.

3. ViewModel이 파기되면 모든 이벤트 리스너가 자동으로 제거 됩니다. 이벤트 제거에 대한 걱정이 필요 없어집니다.

    이것이 Vue.js에서 HTML로 된 리스너를 사용하는 이유입니다!

----------------------------------------------------------

폼 입력 바인딩

 기본 사용법

    v-model 디렉티브를 사용하여 폼 input과 textarea 엘리먼트에 양방향 데이터 바인딩을 생성할 수 있습니다.
    입력 유형에 따라 엘리먼트를 업데이트 하는 올바른 방법을 자동으로 선택합니다.
    약간 이상하지만 v-model은 기본적으로 사용자 입력 이벤트에 대한 데이터를 업데이트하는 “syntax sugar”이며 일부 경우에 특별한 주의를 해야합니다.

 * v-model은 모든 form 엘리먼트의 초기 value와 checked 그리고 selected 속성을 무시합니다. 항상 Vue 인스턴스 데이터를 원본 소스로 취급합니다.
   컴포넌트의 data 옵션 안에 있는 JavaScript에서 초기값을 선언해야합니다.

 * IME (중국어, 일본어, 한국어 등)가 필요한 언어의 경우 IME 중 v-model이 업데이트 되지 않습니다. 이러한 업데이트를 처리하려면 input 이벤트를 대신 사용하십시오.

 -------------------------------------------------------

문자열

    <input v-model="message" placeholder="여기를 수정해보세요">
    <p>메시지: {{ message }}</p>

여러줄을 가진 문장

    <span>여러 줄을 가지는 메시지:</span>
    <p style="white-space: pre-line">{{ message }}</p>
    <br>
    <textarea v-model="message" placeholder="여러줄을 입력해보세요"></textarea>

* 텍스트 영역의 보간 (<textarea>{{ text }}</textarea>)은 작동하지 않습니다. 대신 v-model를 사용하십시오.

----------------------------------------------------------------

체크박스

    하나의 체크박스는 단일 boolean 값을 가집니다.

    <input type="checkbox" id="checkbox" v-model="checked">
    <label for="checkbox">{{ checked }}</label>

    * 체크되어있으면 true, 안되어있으면 false



- 여러개의 체크박스는 같은 배열을 바인딩 할 수 있습니다

    <div id='example-3'>
        <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
        <label for="jack">Jack</label>
        <input type="checkbox" id="john" value="John" v-model="checkedNames">
        <label for="john">John</label>
        <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
        <label for="mike">Mike</label>
        <br>
        <span>체크한 이름: {{ checkedNames }}</span>
    </div>

    new Vue({
        el: '#example-3',
        data: {
            checkedNames: []
        }
    })

------------------------------------------------------------

라디오

    <input type="radio" id="one" value="One" v-model="picked">
    <label for="one">One</label>
    <br>
    <input type="radio" id="two" value="Two" v-model="picked">
    <label for="two">Two</label>
    <br>
    <span>선택: {{ picked }}</span>

셀렉트

    하나의 셀렉트

    <select v-model="selected">
        <option disabled value="">Please select one</option>
        <option>A</option>
        <option>B</option>
        <option>C</option>
    </select>
    <span>선택함: {{ selected }}</span>

    new Vue({
        el: '...',
        data: {
            selected: ''
        }
    })

* v-model 표현식의 초기 값이 어떤 옵션에도 없으면, <select> 엘리먼트는 “선택없음” 상태로 렌더링됩니다.
  iOS에서는 이 경우 변경 이벤트가 발생하지 않아 사용자가 첫 번째 항목을 선택할 수 없게됩니다.
  따라서 위 예제처럼 사용하지 않는 옵션에 빈 값을 넣는 것이 좋습니다.

다중 셀렉트 (배열을 바인딩 합니다):

    <select v-model="selected" multiple>
        <option>A</option>
        <option>B</option>
        <option>C</option>
    </select>
    <br>
    <span>Selected: {{ selected }} </span>

---------------------------------------------------

v-for를 이용한 동적 옵션 렌더링

    <select v-model="selected">
        <option v-for="option in options" v-bind:value="option.value">
            {{ option.text }}
        </option>
    </select>
    <span>Selected: {{ selected }}</span>

    new Vue({
        el: '...',
            data: {
                selected: 'A',
                options: [
                    { text: 'One', value: 'A' },
                    { text: 'Two', value: 'B' },
                    { text: 'Three', value: 'C' }
                ]
            }
    })

---------------------------------------------------------

값 바인딩하기

    라디오, 체크박스 및 셀렉트 옵션의 경우, v-model 바인딩 값은 보통 정적인 문자열(또는 체크 박스의 boolean) 입니다.

<!-- `picked` 는 선택시 문자열 "a" 입니다 -->
<input type="radio" v-model="picked" value="a">

<!-- `toggle` 는 true 또는 false 입니다 -->
<input type="checkbox" v-model="toggle">

<!-- `selected`는 "ABC" 선택시 "abc" 입니다 -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>

    그러나 때로 값을 Vue 인스턴스에 동적 속성에 바인딩 해야할 수 있습니다. v-bind를 사용할 수 있습니다. v-bind를 사용하면 입력 값을 문자열이 아닌 값에 바인딩 할 수도 있습니다.

-------------------------------------------------------

폼이벤트

change - 선택 상자, 체크박스, 라디오 버튼의 상태가 변경되었을 때.

-------------------------------------------------------

수식어

.lazy

    기본적으로, v-model은 각 입력 이벤트 후 입력과 데이터를 동기화 합니다. (단 앞에서 설명한 IME 구성은 제외됩니다.) .lazy 수식어를 추가하여 change 이벤트 이후에 동기화 할 수 있습니다.

    <!-- "input" 대신 "change" 이후에 동기화 됩니다. -->
    <input v-model.lazy="msg" >

.number

    사용자 입력이 자동으로 숫자로 형변환 되기를 원하면, v-model이 관리하는 input에 number 수식어를 추가하면 됩니다.

    <input v-model.number="age" type="number">
    type="number"를 사용하는 경우에도 HTML 입력 엘리먼트의 값은 항상 문자열을 반환하기 때문에 이것은 종종 유용하게 사용할 수 있습니다.

.trim

    v-model이 관리하는 input을 자동으로 trim 하기 원하면, trim 수정자를 추가하면 됩니다.
    <input v-model.trim="msg">

-------------------------------------------------------------------

v-model 과 컴포넌트

    Vue의 컴포넌트에 익숙하지 않으면 지금은 보지 않아도 괜찮습니다.

    HTML의 기본 제공 input 유형이 항상 사용자의 요구를 만족시킬 수는 없습니다.
    다행히 Vue 컴포넌트를 사용하면 완전히 사용자 정의 된 동작으로 재사용 가능한 input을 만들 수 있습니다.
    이 input은 v-model에도 작동합니다! 자세한 컴포넌트 가이드의 사용자 정의 입력을 참조하십시오.

----------------------------------------------------------------------

컴포넌트가 무엇인가요?

    컴포넌트는 Vue의 가장 강력한 기능 중 하나입니다. 기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 캡슐화하는 데 도움이 됩니다.
    상위 수준에서 컴포넌트는 Vue의 컴파일러에 의해 동작이 추가된 사용자 지정 엘리먼트입니다. 경우에 따라 특별한 is 속성으로 확장 된 원시 HTML 엘리먼트로 나타날 수도 있습니다.

    Vue 컴포넌트는 Vue 인스턴스이기도 합니다. 그러므로 모든 옵션 객체를 사용할 수 있습니다. (루트에만 사용하는 옵션은 제외) 그리고 같은 라이프사이클 훅을 사용할 수 있습니다.

------------------------------------------------------------------------

컴포넌트 사용하기

전역 등록

    이전 섹션에서 다음을 사용하여 새 Vue 인스턴스를 만들 수 있음을 알게 되었습니다.

    new Vue({
        el: '#some-element',
        // 옵션
    })

    전역 컴포넌트를 등록하려면, Vue.component(tagName, options)를 사용합니다.

    Vue.component('my-component', {
        // 옵션
    })

    * Vue는 사용자 지정 태그 이름에 대해 W3C 규칙을 적용하지 않습니다 (모두 소문자이어야 하고 하이픈을 포함해야합니다). 그러나 이 규칙을 따르는 것이 좋습니다.

    일단 등록되면, 컴포넌트는 인스턴스의 템플릿에서 커스텀 엘리먼트,<my-component></my-component>로 사용할 수 있습니다.
    루트 Vue 인스턴스를 인스턴스화하기 전에 컴포넌트가 등록되어 있는지 확인하십시오. 전체 예제는 다음과 같습니다.

    <div id="example">
        <my-component></my-component>
    </div>

    // 등록
    Vue.component('my-component', {
        template: '<div>사용자 정의 컴포넌트 입니다!</div>'
    })

    // 루트 인스턴스 생성
    new Vue({
        el: '#example'
    })

    아래와 같이 렌더링 됩니다.

    <div id="example">
        <div>사용자 정의 컴포넌트 입니다!</div>
    </div>

지역 등록

    모든 컴포넌트를 전역으로 등록 할 필요는 없습니다. 컴포넌트를 components 인스턴스 옵션으로 등록함으로써 다른 인스턴스/컴포넌트의 범위에서만 사용할 수있는 컴포넌트를 만들 수 있습니다:

    var Child = {
        template: '<div>사용자 정의 컴포넌트 입니다!</div>'
    }

    new Vue({
        // ...
        components: {
            // <my-component> 는 상위 템플릿에서만 사용할 수 있습니다.
            'my-component': Child
        }
    })

    동일한 캡슐화는 디렉티브와 같은 다른 등록 가능한 Vue 기능에도 적용됩니다.

------------------------------------------------------------------------------

DOM 템플릿 구문 분석 경고

    DOM을 템플릿으로 사용할 때 (예 : el 옵션을 사용하여 기존 콘텐츠가 있는 엘리먼트를 마운트하는 경우),
    Vue는 템플릿 콘텐츠만 가져올 수 있기 때문에 HTML이 작동하는 방식에 고유한 몇 가지 제한 사항이 적용됩니다.
    이는 브라우저가 구문 분석과 정규화한 후에 작동합니다. 가장 중요한 것은<ul>,<ol>,<table>과<select>와 같은 일부 엘리먼트는
    그 안에 어떤 엘리먼트가 나타날 수 있는지에 대한 제한을 가지고 있으며, <option>과 같이 특정 다른 엘리먼트 안에만 나타날 수 있습니다.

    이러한 제한이 있는 엘리먼트가 있는 사용자 지정 컴포넌트를 사용하면 다음과 같은 문제가 발생할 수 있습니다.

    <table>
        <my-row>...</my-row>
    </table>

    사용자 지정 컴포넌트 <my-row> 는 잘못된 컨텐츠가 되어, 결과적으로 렌더링시 에러를 발생시킵니다. 해결 방법은 is 특수 속성을 사용하는 것입니다 :

    <table>
        <tr is="my-row"></tr>
    </table>

    다음 소스 중 하나에 포함되면 문자열 템플릿을 사용하는 경우에는 이러한 제한 사항이 적용되지 않습니다.:

        1. <script type="text/x-template">
        2. JavaScript 인라인 템플릿 문자열
        3. .vue 컴포넌트

    따라서 가능한 경우 항상 문자열 템플릿을 사용하는 것이 좋습니다.

--------------------------------------------------------------

마운트란 외부 장치를 컴퓨터에서 사용할 수 있도록 자리를 (잠시) 내주는 개념이다.

외부에 있는걸 사용할 수 있도록 자리를 줌.

예) Vue.js에서 el 옵션을 이용하여 기존 콘텐츠가 있는 element(HTML 요소)를 마운트.

    * 뷰에서 element를 사용할 수 있게끔 해주었다.

--------------------------------------------------------------

*** 컴포넌트에서 data 는 반드시 함수여야합니다.

Vue 생성자에 사용할 수 있는 대부분의 옵션은 컴포넌트에서 사용할 수 있습니다. 한가지 특별한 경우가 있습니다. data 는 함수여야 합니다. 실제로 이를 사용하는 경우에:

    Vue.component('my-component', {
        template: '<span>{{ message }}</span>',
        data: {
            message: 'hello'
        }
    })

그런 다음 Vue는 중단하고 콘솔에서 경고를 합니다. data는 컴포넌트 인스턴스의 함수여야합니다. 규칙이 존재하는 이유를 이해하는 것이 좋습니다. 따라서 다음과 같이 사용하십시오.

HTML

    <div id="example-2">
        <simple-counter></simple-counter>
        <simple-counter></simple-counter>
        <simple-counter></simple-counter>
    </div>

JS

    var data = { counter: 0 }

    Vue.component('simple-counter', {
        template: '<button v-on:click="counter += 1">{{ counter }}</button>',
        // 데이터는 기술적으로 함수이므로 Vue는 따지지 않지만
        // 각 컴포넌트 인스턴스에 대해 같은 객체 참조를 반환합니다.
        data: function () {
            return data
        }
    })

    new Vue({
        el: '#example-2'
    })

이런! 세 개의 컴포넌트 인스턴스가 모두 같은 data 객체를 공유하므로 하나의 카운터를 증가 시키면 모두 증가합니다! 대신 새로운 데이터 객체를 반환하여 이 문제를 해결합시다.

    data: function () {
        return {
            counter: 0
        }
    }

이제 모든 카운터에는 각각 고유한 내부 상태가 있습니다.

----------------------------------------------------------------------

컴포넌트 작성

    컴포넌트는 부모-자식 관계에서 가장 일반적으로 함께 사용하기 위한 것입니다. 컴포넌트 A는 자체 템플릿에서 컴포넌트 B를 사용할 수 있습니다.
    그들은 필연적으로 서로 의사 소통이 필요합니다. 부모는 자식에게 데이터를 전달해야 할 수도 있으며, 자식은 자신에게 일어난 일을 부모에게 알릴 필요가 있습니다.
    그러나 부모와 자식이 명확하게 정의된 인터페이스를 통해 가능한한 분리된 상태로 유지하는 것도 매우 중요합니다.
    이렇게하면 각 컴포넌트의 코드를 상대적으로 격리 할 수 있도록 작성하고 추론할 수 있으므로 유지 관리가 쉽고 잠재적으로 쉽게 재사용 할 수 있습니다.

    Vue.js에서 부모-자식 컴포넌트 관계는 props는 아래로, events 위로 라고 요약 할 수 있습니다. 부모는 props를 통해 자식에게 데이터를 전달하고
    자식은 events를 통해 부모에게 메시지를 보냅니다. 어떻게 작동하는지 보겠습니다.

            <-Emit Events-
    Parent                  Child
             -Pass Props->

    * 부모는 자식에게 데이터를 전달해야 할 수도 있고, 자식은 자신에게 일어난 일을 부모에게 알릴 필요가 있다.

------------------------------------------------------------------------

Props

Props로 데이터 전달하기

    모든 컴포넌트 인스턴스에는 자체 격리 된 범위 가 있습니다. 즉, 하위 컴포넌트의 템플릿에서 상위 데이터를 직접 참조 할 수 없으며
    그렇게 해서는 안됩니다. 데이터는 props 옵션 을 사용하여 하위 컴포넌트로 전달 될 수 있습니다.

    prop는 상위 컴포넌트의 정보를 전달하기위한 사용자 지정 특성입니다.
    하위 컴포넌트는props 옵션을 사용하여 수신 할 것으로 기대되는 props를 명시적으로 선언해야합니다.

    Vue.component('child', {
        // props 정의
        props: ['message'],
        // 데이터와 마찬가지로 prop은 템플릿 내부에서 사용할 수 있으며
        // vm의 this.message로 사용할 수 있습니다.
        template: '<span>{{ message }}</span>'
    })

    그런 다음 일반 문자열을 다음과 같이 전달할 수 있습니다.

    <child message="안녕하세요!"></child>

    결과 :

            안녕하세요!

-----------------------------------------------------------------------------

camelCase vs. kebab-case

    HTML 속성은 대소 문자를 구분하지 않으므로 문자열이 아닌 템플릿을 사용할 때
    camelCased prop 이름에 해당하는 kebab-case(하이픈 구분)를 사용해야 합니다.

    Vue.component('child', {
        // JavaScript는 camelCase로 쓰자.
        props: ['myMessage'],
        template: '<span>{{ myMessage }}</span>'
    })

    <!-- HTML는 kebab-case로 쓰자. -->
    <child my-message="안녕하세요!"></child>

문자열 템플릿을 사용하는 경우에도 이 제한이 적용되지 않습니다.

------------------------------------------------------------------------------

동적 Props

    정규 속성을 표현식에 바인딩하는 것과 비슷하게, v-bind를 사용하여 부모 데이터의
    props를 동적으로 바인딩 할 수 있습니다. 데이터가 상위에서 업데이트 될 때마다 하위 데이터로도 전달됩니다.

    <div>
        <input v-model="parentMsg">
        <br>
        <child v-bind:my-message="parentMsg"></child>
    </div>

    v-bind에 대한 단축 구문을 사용하는 것이 더 간단합니다.

    <child :my-message="parentMsg"></child>

객체의 모든 속성을 props로 전달하려면, 인자없이 v-bind를 쓸 수 있습니다. (v-bind:prop-name 대신 v-bind). 예를 들어 todo 객체가 있다면,

    todo: {
        text: 'Learn Vue',
        isComplete: false
    }

    그런 다음,

    <todo-item v-bind="todo"></todo-item>

    이것은 다음과 같은 동작을합니다.:

    <todo-item
        v-bind:text="todo.text"
        v-bind:is-complete="todo.isComplete"
    ></todo-item>

------------------------------------------------------------------------------

리터럴 vs. 동적

    초보자가 흔히 범하는 실수는 리터럴 구문을 사용하여 숫자를 전달하려고 시도하는 것입니다.

    <!-- 이것은 일반 문자열 "1"을 전달합니다. -->
    <comp some-prop="1"></comp>

    그러나 이것은 리터럴 prop이기 때문에 그 값은 실제 숫자가 아닌 일반 문자열 "1" 로 전달됩니다.
    실제 JavaScript 숫자를 전달하려면 아래처럼 값이 JavaScript 표현식으로 평가되도록 v-bind를 사용해야합니다.

    <!-- 이것은 실제 숫자로 전달합니다. -->
    <comp v-bind:some-prop="1"></comp>

------------------------------------------------------------------------------

단방향 데이터 흐름

    모든 props는 하위 속성과 상위 속성 사이의 단방향 바인딩을 형성합니다.
    상위 속성이 업데이트되면 하위로 흐르게 되지만 그 반대는 안됩니다.
    이렇게하면 하위 컴포넌트가 실수로 부모의 상태를 변경하여 앱의 데이터 흐름을 추론하기 더 어렵게 만드는 것을 방지할 수 있습니다.

    일반적으로 prop을 변경시키고 싶은 유혹을 불러 일으킬 수있는 두 가지 경우가 있습니다.

    이 prop는 초기 값을 전달 하는데만 사용되며 하위 컴포넌트는 이후에 이를 로컬 데이터 속성으로 사용하기만 합니다.

    prop는 변경되어야 할 원시 값으로 전달됩니다.

    이러한 사용 사례에 대한 적절한 대답은 다음과 같습니다.

    - prop의 초기 값을 초기 값으로 사용하는 로컬 데이터 속성을 정의 하십시오.

    props: ['initialCounter'],
        data: function () {
            return { counter: this.initialCounter }
    }

    - prop 값으로 부터 계산된 속성을 정의 합니다.

    props: ['size'],
        computed: {
            normalizedSize: function () {
                return this.size.trim().toLowerCase()   // props 값인 size를 공백제거 후 소문자로 변환하고 리턴한다.
        }
    }

* 자바 스크립트의 객체와 배열은 참조로 전달되므로 prop가 배열이나 객체인 경우 하위 객체 또는 배열 자체를 부모 상태로 변경하면 부모 상태에 영향을 줍니다.

------------------------------------------------------------------------------------------

Prop 검증

    컴포넌트가 받는 중인 prop에 대한 요구사항을 지정할 수 있습니다.
    요구사항이 충족 되지 않으면 Vue에서 경고를 내보냅니다.
    이 기능은 다른 사용자가 사용할 컴포넌트를 제작할 때 특히 유용합니다.

    props를 문자열 배열로 정의하는 대신 유효성 검사 요구사항이 있는 객체를 사용할 수 있습니다.

    Vue.component('example', {
        props: {
        // 기본 타입 확인 (`null` 은 어떤 타입이든 가능하다는 뜻입니다)
        propA: Number,
        // 여러개의 가능한 타입
        propB: [String, Number],
        // 문자열이며 꼭 필요합니다
        propC: {
            type: String,
            required: true
        },
        // 숫자이며 기본 값을 가집니다
        propD: {
            type: Number,
            default: 100
        },
        // 객체/배열의 기본값은 팩토리 함수에서 반환 되어야 합니다.
        propE: {
            type: Object,
            default: function () {
                return { message: 'hello' }
            }
        },
        // 사용자 정의 유효성 검사 가능
        propF: {
            validator: function (value) {
                return value > 10
            }
          }
        }
    })

type은 다음 네이티브 생성자 중 하나를 사용할 수 있습니다.

    String
    Number
    Boolean
    Function
    Object
    Array
    Symbol

또한, type 은 커스텀 생성자 함수가 될 수 있고, assertion은 instanceof 체크로 만들어 질 것입니다.

props 검증이 실패하면 Vue는 콘솔에서 경고를 출력합니다(개발 빌드를 사용하는 경우).
props는 컴포넌트 인스턴스가 생성되기 전에 검증되기 때문에 default 또는 validator 함수 내에서
data, computed 또는 methods와 같은 인스턴스 속성을 사용할 수 없습니다.

* data, computed, methods 는 인스턴스 속성이므로 props 와 관련된 함수 default 또는 validator 안에서
    사용이 불가능하다. (props는 컴포넌트 인스턴스가 생성되기 전에 검증받기 때문.)

-----------------------------------------------------------------------------------

객체가 메모리에 할당되어 실제 사용될 때를 인스턴스라고 한다.
즉, 인스턴스는 추상화 개념 또는 클래스 객체, 컴퓨터 프로세스 등과 같은 템플릿이 실제 구현된 것이다.

인스턴스화는 클래스 내의 객체에 대해 특정한 변형을 정의하고, 이름을 붙인 다음,
그것을 물리적인 어떤 장소에 위치시키는 등의 작업을 통해, 인스턴스를 만드는 것을 의미한다.

--------------------------------------------------------------------------------------

Props가 아닌 속성

    Props가 아닌 속성은 컴포넌트로 전달되지만 해당 props는 정의되지 않은 속성입니다.

    명시적으로 정의된 props는 하위 컴포넌트에 정보를 전달하는데 적절하지만 컴포넌트 라이브러리를 만드는 경우
    컴포넌트가 사용될 수있는 상황을 항상 예측할 수는 없습니다. 이것이 컴포넌트가 컴포넌트의 루트 요소에 추가되는 임의의 속성을 허용해야하는 이유입니다.

    예를 들어, 우리가 input에 data-3d-date-picker 속성을 요구하는 부트스트랩 플러그인으로 써드 파티 bs-date-input 컴포넌트를 사용하고 있다고 상상해보세요.
    이 속성을 컴포넌트 인스턴스에 추가 할 수 있습니다.

    <bs-date-input data-3d-date-picker="true"></bs-date-input>
    그리고 data-3d-date-picker="true"속성은 bs-date-input의 루트 엘리먼트에 자동으로 추가 될 것입니다.

----------------------------------------------------------------------------------------

서드파티?

프로그래밍 개발을 하다보면, 편하고 효율적인 개발을 위해, 플러그인이나 라이브러리 또는 프레임워크등을 사용한다.
예를 들면 프로그래밍 개발과 개발자 사이에 플러그인, 라이브러리, 프레임워크를 서드파티로 볼 수 있다.

만약 개발을 완료했다고 한다면, 서비스와 사용자를 이어주는 서드파티는 응용프로그램 or 어플리케이션 or 웹서비스입니다.
이처럼 제3자로써 중간 다리의 역할을 하는 것을 서드파티라 합니다.

---------------------------------------------------------------------------------------

존재하는 속성 교체/병합

    이 파일이 bs-date-input의 템플릿이라고 가정합니다:

    <input type="date" class="form-control">

    데이트피커 플러그인의 테마를 추가하려면 다음과 같이 특정 클래스를 추가해야 할 수도 있습니다.

    <bs-date-input
        data-3d-date-picker="true"
        class="date-picker-theme-dark"
    ></bs-date-input>

    이 경우 class에 대한 두 개의 서로 다른 값이 정의됩니다.

    1. 템플릿의 컴포넌트에 의해 설정된 form-control
    2. date-picker-theme-dark는 부모에 의해 컴포넌트로 전달됩니다.

    대부분의 속성의 경우 컴포넌트에 제공된 값은 컴포넌트에서 설정된 값을 대체합니다.
    예를 들어, type="large"가 전달되면 type="date"를 대체할 것이고 아마도 망가뜨릴 것입니다!
    다행스럽게도 class와 style 속성은 똑똑하기 때문에 두 값이 합쳐져서 최종 값인 form-control date-picker-theme-dark를 만듭니다.

    *** 설정된 값(탬플릿) 대신 컴포넌트에 제공된 값( 예 : <my-component class="added" type="large"></my-component> )에 똑같은 속성을 써주면 대체된다.
        class와 style 속성은 똑똑하기 때문에 두 값이 합쳐진다.

        즉, 컴포넌트에서 속성은 덮어써진다. class와 style 속성은 병합된다.
        이미 설정된 탬플릿이 아니라 HTML에서 써주는

----------------------------------------------------------------------------------------------------

    우리는 부모가 prop을 사용하여 자식에게 데이터를 전달할 수 있다는 것을 알았지만, 문제가 발생했을 때 어떻게 부모에게 다시 알릴까요?
    바로 Vue의 사용자 정의 이벤트 시스템이 들어오는 곳입니다.

v-on 을 이용한 사용자 지정 이벤트

    모든 Vue 인스턴스는 다음과 같은 이벤트 인터페이스를 구현합니다.

        * $on(eventName)을 사용하여 이벤트를 감지
        * $emit(eventName)을 사용하여 이벤트를 트리거

      * Vue의 이벤트 시스템은 브라우저의 EventTarget API와 별개입니다. 비슷하게 작동하지만 $on 과 $emit 는 addEventListener 와 dispatchEvent의 별칭이 아닙니다.

    또한, 부모 컴포넌트는 자식 컴포넌트가 사용되는 템플릿에서 직접 v-on 을 사용하여 자식 컴포넌트에서 보내진 이벤트를 청취할 수 있습니다.

      * $on은 자식에서 호출한 이벤트는 감지하지 않습니다. v-on을 템플릿에 반드시 지정해야 합니다. 아래의 예제를 보십시오.

    <div id="counter-event-example">
        <p>{{ total }}</p>
        <button-counter v-on:increment="incrementTotal"></button-counter>
        <button-counter v-on:increment="incrementTotal"></button-counter>
    </div>

    Vue.component('button-counter', {
        template: '<button v-on:click="incrementCounter">{{ counter }}</button>',
        data: function () {
            return {
                counter: 0
            }
        },
        methods: {
            incrementCounter: function () {
                this.counter += 1
                this.$emit('increment')
            }
        },
    })

    new Vue({
        el: '#counter-event-example',
        data: {
            total: 0
        },
        methods: {
            incrementTotal: function () {
                this.total += 1
            }
        }
    })

        이 예제에서는 하위 컴포넌트가 외부에서 발생 하는 것과 완전히 분리 된다는 점에 유의해야 합니다.
        부모 컴포넌트가 신경 쓸 수 있는 경우를 대비하여 자체 활동에 대한 정보를 보고 하는 것뿐입니다.

    컴포넌트에 네이티브 이벤트 바인딩

        컴포넌트의 루트 엘리먼트에서 네이티브 이벤트를 수신하려는 경우가 있을 수 있습니다. 이러한 경우 v-on 에 .native 수식자를 사용할 수 있습니다.

        예 :  <my-component v-on:click.native="doTheThing"></my-component>

.sync 수식어

    2.3.0+

    일부 경우에 속성에 “양방향 바인딩”이 필요할 수 있습니다. Vue 1버전에 있던 .sync 수식어와 동일합니다.
    자식 컴포넌트가 .sync를 가지는 속성을 변경하면 값의 변경이 부모에 반영됩니다. 편리하지만 단방향 데이터 흐름이 아니기 때문에 장기적으로 유지보수에 문제가 생깁니다.
    자식 속성을 변경하는 코드는 부모의 상태에 영향을 미칩니다.

    이 때문에 .sync는 2.0버전에서 삭제되었습니다. 그러나 재사용 가능한 컴포넌트를 만들 때 유용할 수 있다는 점을 알게 되었습니다.
    부모 상태에 영향을 미치는 코드를 더욱 일관적이고 명백하게 만들어야합니다.

    2.3 버전에서 속성을 위한 .sync 수식어를 다시 만들었습니다. 자동으로 v-on로 확장되는 신택스 슈가입니다.

    따라서 아래 코드는

        <comp :foo.sync="bar"></comp>

    아래와 같습니다.

        <comp :foo="bar" @update:foo="val => bar = val"></comp>

    하위 컴포넌트가 foo를 갱신하려면 속성을 변경하는 대신 명시적으로 이벤트를 보내야합니다.

        this.$emit('update:foo', newValue)

사용자 정의 이벤트를 사용하여 폼 입력 컴포넌트 만들기

    사용자 정의 이벤트는 v-model 에서 작동하는 사용자 정의 입력을 만드는데에도 사용할 수 있습니다. 기억하세요.

    <input v-model="something">
    위 문장은 아래와 같습니다.

    <input
        v-bind:value="something"
        v-on:input="something = $event.target.value">
    컴포넌트와 함께 사용하면 다음과 같이 간단해집니다.

    <custom-input
        :value="something"
        @input="value => { something = value }">
    </custom-input>
    따라서 v-model을 사용하는 컴포넌트는 (2.2.0버전 이상에서 설정을 조작할 수 있습니다.)

    value prop를 가집니다.
    새로운 값으로 input 이벤트를 내보냅니다.
    매우 간단한 통화 입력을 사용하는 모습을 보겠습니다.

--------------------------------------------------------------------------------

자바스크립트 메서드 indexOf()

indexOf () 메서드는 배열에서 지정된 요소를 찾을 수 있는 첫 번째 인덱스를 반환하고 존재하지 않으면 -1을 반환합니다.
    ( Array.prototype.indexOf() )

* arr.indexOf(searchElement, fromIndex)

    searchElement

        배열에서 찾을 요소입니다.

    fromIndex Optional

        검색을 시작할 색인입니다. 인덱스가 배열의 길이보다 크거나 같은 경우 -1이 반환되므로 배열이 검색되지 않습니다.
        제공된 색인 값이 음수이면 배열 끝에서부터의 오프셋 값으로 사용됩니다.

        참고 : 제공된 색인이 음수이면 배열은 여전히 앞에서 뒤로 검색됩니다.
               계산 된 인덱스가 0보다 작 으면 전체 배열이 검색됩니다.
               기본값 : 0 (전체 배열 검색).

    반환 값

        배열 내의 요소의 최초의 인덱스. 발견되지 않으면 -1.

--------------------------------------------------------------------------------

$refs

    vm.$refs

        ref가 등록된 자식 컴포넌트를 보관하는 객체입니다.

        * ref 속성을 이용하여 DOM 요소에 접근이 가능하다.

    ex)

        컴포넌트의 methods에서 this.$refs.input.value를 통해 탬플릿에 ref(자식 컴포넌트)를 등록하여 참조가능.

         <input ref="input" v-bind:value="value" v-on:input="updateValue($event.target.value)">

-------------------------------------------------------------------------------

* Vue 인스턴스는 모든 컴포넌트의 상위 컴포넌트로서 자식 컴포넌트를 여러개 가질 수 있는데 이 component 함수로 만들어 자식으로 사용한다.

    컴포넌트가 여러개 생기면서 이들간의 커뮤니케이션 방법도 필요하다. 트리형태로 구성했기 때문에 상위에 있는 것을 부모(Parent) 컴포넌트,
    아래 있는것(중첩되어 있는)을 자녀(Child) 컴포넌트라고 부른다.

    데이터는 부모 -> 자녀 방향으로만 전달할 수 있다. 이점은 리액트의 단방향 데이터 흐름과 같다. 그래서 뷰js는 자녀 컴포넌트의 프로퍼티를 이용해 데이터를 전달한

* Vue는 앵귤러의 양방향 데이터 바인딩과 리엑트의 가상돔을 가지고 있습니다.

    앵귤러가 디렉티브에 치중되어 있다면, Vue는 컴포넌트에 치중되어 있습니다.

* 리엑트와 뷰는 아래 비슷한 특징이 있어요.

    가상돔을 사용한다.
    리엑티브(reactive)하고 컴포져블(compose-able)한 뷰 컴포넌트를 제공한다.
    핵심 라이브러리에 집중한다. (라우팅과 상태관리를 포함)

    리액트와 뷰는 기능면에서 상당히 비슷합니다.

    뷰에서 v-model 디렉티브를 사용하면 양방향 바인딩은 매우 간단합니다. 리엑트에서는 엄청 길죠.
    더 적은 라인과 간단한 코드로 뷰가 이깁니다.

    결론

        현재 뷰는 페이스북의 리액트나 구글의 앵귤러 만큼 인기 있는건 아닙니다. 하지만 많은 개발자들이 뷰로 옮기고 있죠.
        라라벨(Laravel) 커뮤니티도 선호하는 프론트엔드 프레임웍으로써 뷰를 선택했습니다.


참고 : http://blog.jeonghwan.net/

------------------------------------------------------------------------------------------

Vue 인스턴스

    그럼 헬로월드 코드부터 살펴보자.

    <div id="app">{{ msg }}</div>

    <script>
        var vm = new Vue({
            el: '#app',
            data: {
            msg: 'Hello world'
            }
        });
    </script>

    Vue 생성자 함수로 뷰모델을 만드는데 이것이 Vue 인스턴스다. 이것은 자바스크립트 객체인데 내부적으로 연결될 템플릿이 필요하다. 그것을 el 키에 셀렉터 값으로 넣어주면 된다.

        {
            el: '#app'
        }

    그리고 data 객체는 인스턴스의 상태를 저장하는 역할을 하는데 템플릿에 바인딩할 데이터들의 집합이다. msg 변수 값을 템플릿에 인터폴레이션 문법으로 바인딩하여 출력하였다.

        {{ msg }}

    브라우져로 확인해 보면 메세지 변수값인 ‘Hello world’ 문자열이 출력된다.


    뷰 인스턴스에는 methods 객체도 있는데 이것은 인스턴스의 행동 즉 메써드의 집합이다. 이것은 주로 돔에 연결할 이벤트 핸들러로 사용된다.
    버튼을 클릭하면 경고를 띄워주는 클릭 이벤트 핸들러를 아래와 같이 만들 수 있다.

    <div id="app">
        <button v-on:click="onClick">클릭미!</button>
    </div>

    <script>
        var vm = new Vue({
            el: '#app',
            methods: {
                onClick: function(){ alert('Hello world'); }
            }
        });
    </script>

    데이터 바인딩과 이벤트 바인딩 부분이 앵귤러와 매우 유사하다. 에반 유는 앵귤러를 사용하면서 데이터 바인딩 방법에 대한 영향을 많이 받았다고 한다.

    하지만 그는 여기에 한 가지 더 추가한 것이 있는데 computed 객체다. 이것은 methods와 비슷한 역할을 하지만 캐쉬를 가지고 있어서 함수 본문에서 사용하는
    상태값에 변화가 없으면 함수를 수행하지 않고 저장한 캐쉬값을 바로 반환하기 때문에 비교적 빠르다.

    <div id="app">{{ greeting }}</div>

    <script>
        var vm = new Vue({
            el: '#app',
            data: { name: 'Chris' },
            computed: {
                greeting: function(){ return 'Hello ' + this.name; }
            }
        });
    </script>

* 인스턴스는 생성 -> 마운트 -> 소멸의 라이프 사이클을 가지고 있다.

    vue-lifecycle

    인스터스 이벤트 사이클을 이해할 필요가 있는데 각 시점마다 이벤트 훅을 사용할수 있기 때문이다.
    내가 본 샘플코드에서는 객체 생성후 백엔드 리소스를 요청을 위해 create 훅에 ajax를 호출하고 있었다.
    뷰모델과 돔을 연결할 데이터를 동적으로 백엔드에 가져오는 시점에서 create에서 처리하는 것이다. DOMContentLoaded 이벤트와는 다른 시점이다.

    var vm = new Vue({
        created: function() {
            fetchData();
        },
    });


Vue 컴포넌트

    - 커스텀 태그
    - 템플릿
    - 돔과 스타일시트의 캡슐화

    이러한 컴포넌트는 재사용할 수 있어 프로그램 개발에 효율성을 높일수 있다. 이미 앵귤러, 리엑트, 폴리머 등 유수 프레임웍에서는 웹 컴포넌트 제작 방법을 구현해놨다.

        앵귤러: angular.module().component(‘MyComponent’, { … })
        리엑트: class MyComponent extends React.Component { … }
        폴리머: class MyElement extends HTMLElement { … }

    마찬가지로 뷰js도 컴포넌트를 만들수 있는 메서드를 제공한다.

    Vue.componet()

    * Vue 인스턴스는 모든 컴포넌트의 상위 컴포넌트로서 자식 컴포넌트를 여러개 가질 수 있는데 이 component 함수로 만들어 자식으로 사용한다.

    <div id="child">Hello {{ name }}</div>

    <div id="app"><Child></Child></div>

    <script>
        Vue.component('Child', {
            el: '#child',
            data: function() {
                return {
                    name: 'Chris'
                }
            }
        });

        var vm = new Vue({
            el: '#app'
        });
    </script>

    Child 컴포넌트를 정의했는데 Vue 인스턴스를 만들 때와 다른점은 data 부분이다.
    컴포넌트는 재사용이 가능하기 때문에 고유한 데이터를 가지고 있어야 한다.
    data 자체를 반환하다고 생각해보자. ( return data )
    여러개의 컴포넌트 인스턴스가 모두 같은 data 객체를 공유하므로 각 컴포넌트 인스턴스가 독립적으로 작동하지 못하게 된다.
    위처럼 새로운 데이터 객체인 name을 반환하여 문제를 해결한다.

    * 컴포넌트에서 data는 반드시 함수여야 된다! 아니면 에러남.

    컴포넌트가 여러개 생기면서 이들간의 커뮤니케이션 방법도 필요하다.
    트리형태로 구성했기 때문에 상위에 있는 것을 부모(Parent) 컴포넌트, 아래 있는것(중첩되어 있는)을 자식(Child) 컴포넌트라고 부른다.

    vue-component-communication ?

        데이터는 부모 -> 자녀 방향으로만 전달할 수 있다. 이점은 리액트의 단방향 데이터 흐름과 같다. 그래서 뷰js는 자녀 컴포넌트의 프로퍼티를 이용해 데이터를 전달한다.

    <Child name="Chris"></Child>

    <script>
    Vue.component('Child', {
        el: '#child',
        props: ['name']
    });
    </script>

    Child 컴포넌트를 사용하는 부모 컴포넌트 측에서는 Child의 name 속성에 “Chris” 문자열을 데이터로 전달했다.
    Child 컴포넌트는 이 값을 받기 위해 componet 함수 옵션 객체에 props 배열에 ‘name’ 값을 추가하면된다. 필요한 만큼 배열에 추가하는 방식이다.

    한편, 자녀 -> 부모 방향으로는 데이터를 전달이 불가능하다. 커뮤니케이션하는 방법이 없을까? 바로 이벤트를 전달하는 방식이다.
    버튼 엘레멘트가 클릭 이벤트를 발생하고 이를 상위 엘레맨트의 누군가 수신하듯이 말이다.
    Vue.js에서는 자식이 이벤트를 발생(emit)하면 부모에서는 이 이벤트를 수신할 수 있는 핸들러 함수와 연결해 주면 된다.

    <Child v-on:typed="onTyped"></Child>

    <script>
        Vue.component('NameForm', {
            el: '#child',
            methods: {
                onClick: function() {
            this.$emit('typed');
                }
            }
        });
    </script>

    Child 컴포넌트는 onClick 메서드에서 ‘typed’ 이벤트를 발생시킨다. 그럼 부모쪽에서는 typed 이벤트에 연결된 onTyped 메서드를 실행할수 있다.

    작은 규모의 어플리케이션에서는 이러한 방법으로 컴포넌트간의 상태를 공유할 수 있지만 규모가 커지면 상태 관리가 어렵게 될것이고 누군가의 도움이 필요하다.

    리엑트 진영에서는 Redux같은 Flux 구현체들을 만들어 사용하듯이 뷰js에서도 Vuex라는 상태관리 솔루션을 사용할 수 있다.

    뷰js 컴포넌트의 꽃은 단일파일 컴포넌트다. 하나의 파일에 템플릿, 스타일, 로직을 모두 집어 넣을수 있으니 말이다.

    그래서 파일 단위로 컴포넌트를 관리할 수 있다. 물론 빌드 과정을 거지치면서 다시 HTML, CSS, JS 로 나눠지겠지만 개발자가 코드를 컴포넌트 단위로 관리할수 있다는 점이 좋다.

    컴포넌트를 만들고 이것을 모듈시스템으로 가져와서 사용할수 있다.

    ES6의 모듈시스템을 사용하려면 웹팩과 바벨의 도움을 받아야 한다. 직접 개발환경을 꾸밀수도 있지만
    그 전에 쉽고 빠르게 구성해주는 도구도 있다. vue-cli. 이 녀석이 만들어 내는 코드를 분석해 보는 것도 뷰js 개발 환경을 이해하는데 도움이 된다.

출처 : http://blog.jeonghwan.net/vue/2017/03/27/vue.html

-----------------------------------------------------------------

Vue 관련 라이브러리

    Vuex: Flux 아이디어와 유사한 상태 관리 패턴 라이브러리
    Vue-resource: XMLHttpRequest, JSONP 라이브러리 ($.ajax 안써도 됨)
    Vue-router: SPA 구현을 위한 라우터 클라이언트 라이브러리
    Weex: 모바일 크로스플랫폼 개발을 위한 라이브러리 (React Native 같은것)

-----------------------------------------------------------------

컴포넌트의 v-model 사용자 정의(이해 잘 안감)

    2.2.0 버전에서 추가됨

    기본적으로 컴포넌트의 v-model은 value를 보조 변수로 사용하고 input을 이벤트로 사용하지만 체크 박스와 라디오 버튼과 같은 일부 입력 타입은
    다른 목적으로 value 속성을 사용할 수 있습니다. model 옵션을 사용하면 다음 경우에 충돌을 피할 수 있습니다:

    Vue.component('my-checkbox', {
        model: {
            prop: 'checked',
            event: 'change'
        },
        props: {
            // 다른 목적을 위해 `value` prop를 사용할 수 있습니다.
            checked: Boolean,
            value: String
            },
        // ...
    })

    <my-checkbox v-model="foo" value="some value"></my-checkbox>

    아래와 같습니다

    <my-checkbox
        :checked="foo"
        @change="val => { foo = val }"
        value="some value">
    </my-checkbox>

    * checked prop를 명시적으로 선언해야 합니다.

------------------------------------------------------------------

비 부모-자식간 통신

    때로는 두 컴포넌트가 서로 통신 할 필요가 있지만 서로 부모/자식이 아닐 수도 있습니다. 간단한 시나리오에서는 비어있는 Vue 인스턴스를 중앙 이벤트 버스로 사용할 수 있습니다.

    var bus = new Vue()

    // 컴포넌트 A의 메소드
    bus.$emit('id-selected', 1)

    // 컴포넌트 B의 created 훅
    bus.$on('id-selected', function (id) {
        // ...
    })

    보다 복잡한 경우에는 전용 상태 관리 패턴을 고려해야합니다

-------------------------------------------------------------------

https://shlee1353.github.io/2017/11/15/Vue-Quick-Start/ 읽어보고 v-model 사용자 정의 다시 읽어보기.

----------------------------

Do it ! Vue.js !

-------------------------------------------------------

프레임워크 : 개발자들의 개발 생산성을 높이기 위해 일정한 틀과 규칙에 따라 개발하도록 미리 구조를 정의해 놓은 도구
라이브러리 : 자주 사용되는 기능들을 모아 재활용할 수 있도록 정리한 기술 모음집

---------------------------------------------

뷰 코어 라이브러리는 화면단 데이터 표현에 관한 기능들을 중점적으로 지원하지만 프레임워크의 기능인
라우터, 상태 관리, 테스팅 등을 쉽게 결합할 수 있는 형태로도 제공됩니다.
즉 라이브러리 역할뿐만 아니라 프레임워크 역할도 할 수 있다는 의미입니다.
그래서 공식 사이트에서도 뷰를 점진적인 프레임워크(progressive framework)라고 부르고 있습니다.

----------------------------------------

뷰의 특징

1. UI 화면단 라이브러리

    Vue.js 는 UI 화면 개발 방법 중 하나인 MVVM 패턴의 뷰 모델(ViewModel)에 해당하는 화면단 라이브러리입니다.

    뷰              뷰 모델(ViewModel)              모델
    view            돔 리스너(DOM Listener)         model
                    데이터 바인딩(Data Binding)
    돔(DOM)                                        자바스크립트 객체(Javascript Objects)



    화면의 요소들을 제어하는 코드와 데이터 제어 로직을 분리하여 코드를 더 직관적으로 이해할 수 있고, 추후 유지 보수가 편해지기 때문이다.

    뷰(View)               사용자에게 보이는 화면
    돔(DOM)                 HTML 문서에 들어가는 요소(태그, 클래스, 속성 등)의 정보를 담고 있는 데이터 트리
    돔 리스너(DOM Listener) 돔의 변경 내역에 대해 즉각적으로 반응하여 특정 로직을 수행하는 장치
    모델(Model)             데이터를 담는 용기. 보통은 서버에서 가져온 데이터를 자바스크립트 객체형태로 저장한다.
    데이터 바인딩           뷰(View)에 표시되는 내용과 모델의 데이터를 동기화
    (Data Binding)
    뷰 모델(ViewModel)      뷰와 모델의 중간 영역. 돔 리스너와 데이터 바인딩을 제공하는 영역

2. MVVM 구조의 처리 흐름

    ex) 버튼 클릭 -> 돔 리스너에서 버튼의 클릭 감지 -> 버튼이 동작하면 검색 결과를 보여주는 로직이 처리된다. -> 처리과정에서 데이터 바인딩이 관여.
        -> 해당하는 데이터를 모델(Model)에서 가져와 화면에 나타내 준다.


    뷰는 화면의 요소가 변경되거나 조작이 일어날 때 즉각적으로 반응하여 화면의 데이터를 갱신하여 보여주는 역할을 한다.

    MVVM란??

        마크업 언어나 GUI 코드를 비즈니스 로직 또는 백엔드 로직과 분리하여 개발하는 소프트웨어 디자인 패턴.
        즉 화면 앞단(프런트앤드)의 화면 동작과 관련된 로직과 화면 뒷단(백앤드)의 데이터베이스 데이터 처리 로직을 분리하여
        더 깔끔하게 코드를 구성한다는 것이다.

3. 컴포넌트 기반 프레임워크

    뷰가 가지는 또 하나의 큰 특징은 바로 컴포넌트(Component)기반 프레임워크라는 점입니다.

    컴포넌트란 마치 레고 블록과 같습니다. 레고 블록을 잘 조합해서 쌓으면 원하는 모형을 만들 수 있듯이 뷰의 컴포넌트를 조합하여 화면을 구성할 수 있습니다.
    컴포넌트 기반 방식으로 개발하는 이유는 코드를 재사용하기가 쉽기 때문입니다. 그리고 뷰의 경우 컴포넌트를 썼을 때
    HTML 코드에서 화면의 구조를 직관적으로 파악할 수 있습니다. 따라서 프레임워크 자체에서 컴포넌트 방식을 추구하면 모두가 정해진 방식대로 컴포넌트를 활용하므로
    빠르게 구현할 수 있을 뿐만 아니라 남이 작성한 코드를 볼 때도 수월해 집니다.

4. 리액트와 앵귤러의 장점을 가진 프레임워크

    앵귤러의 양방향 데이터 바인딩과 리액트의 단방향 데이터 흐름의 장점을 모두 결합한 프레임워크이다.

    양방향 데이터 바인딩이란? - 화면에 표시되는 값과 프레임워크의 모델 데이터 갑이 동기화되어 한쪽이 변경되면 다른 한쪽도 자동으로 변경되는 것을 의미한다.

    단방향 데이터 흐름이란? - 컴포넌트의 단방향 통신을 의미한다. 컴포넌트 간에 데이터를 전달할 때 항상 상위 컴포넌트에서 하위 컴포넌트 한 방향으로만
                            전달하게끔 프레임워크가 구조화되어 있는 게 바로 단방향 데이터 흐름이다.

    이외에도 빠른 화면 렌더링을 위해 리엑트의 가상 돔 렌더링(Virtual DOM) 방식을 적용하여 사용자간의 상호작용이 많은 요즘의 웹 화면에 적합한 동작 구조를 갖추고 있다.
    가상 돔을 활용하면 특정 돔 요소를 추가하거나 삭제하는 변경이 일어날 때 화면 전체를 다시 그리지 않고 프레임워크에서 정의한 방식에 따라 화면을 갱신한다.

------------------------------------

뷰와 관련된 Atom 패키지 및 테마

    seti-ui는 직관적인 파일 아이콘과 눈에 튀지않는 색깔조합 테마를 제공합니다.

    atom-material-syntax는 자바스크립트 코드 구문 강조색의 조합이 잘 되어 있어 코드의 가독성을 높여줍니다. ( 테마에서 Atom Material 을 적용시켜 주자.)

    language-vue는 싱글 파일 컴포넌트 체계를 학습할 때 반드시 필요합니다. (패키지는 테마와는 다르게 설치하고 별도로 설정해주지 않아도 자동으로 활성화가 됩니다.)

            * 뷰 파일을 열고 tem을 입력하고 탭 또는 마우스로 누르면 컴포넌트 자동 완성 기능이 적용된다.

* 뷰 CLI(Command Line Interface)를 이용하여 쉽게 뷰 프로젝트를 구성하려면 Node.js가 설치되어 있어야 한다.
  또한 뷰 CLI로 생성한 프로젝트에서 프로토타이핑을 할 때도 노드제이에스 서버를 사용하기 때문에 필수적인 환경이다.

    Node.js는 윈도우, 맥, 리눅스 등 다양한 플랫폼에서 서버 사이드(Server-side) 자바스크립트 코드를 실행할 수 있는 실행 환경이다.

    서버사이드 : 웹 화면과 관계된 서버 로직을 처리하는 영역

* 참고로 Node.js는 Current 버전보다 안정적인 LTS(Long Term Support) 버전을 다운로드하는 것이 향후 라이브러리 호환성 관점에서 더 도움이 된다.

또한 뷰 개발자 도구도 설치해주자. (뷰 크롬 플러그인)

    구글에서 vue.js devtools 검색!

뷰로 만든 웹 앱의 구조를 간편하게 디버깅하거나 분석할 수 있다. 크롬, 파이어폭스, 사파리 모두 지원된다.

--------------------------------------

크롬 개발자 도구 실행 단축키

윈도우 : F12

맥OS : cmd + option + |

-----------------------------------

뷰 개발자 도구는 컴포넌트로 구성된 애플리케이션의 구조를 한눈에 확인할 수 있습니다.
그리고 각 컴포넌트별로 정의된 속성의 변화를 실시간으로 확인할 수 있어 뷰로 제작한 웹 앱을 분석하거나
디버깅할 때 유용하게 사용할 수 있습니다.

-----------------------------------

파일 시스템에서 접근하여 브라우저로 실행했으면, 첫 번째 로그 (뷰 크롬 익스텐션을 다운로드해주세요!)가 뜬다.
크롬 브라우저의 설정 -> 도구 더보기 -> 확장 프로그램 에서 뷰 개발자 도구에서 파일 URL에 대한 엑세스 허용을 체크해주면 해결된다.

루트 컴포넌트란?
    뷰 애플리케이션을 실행할 때 가장 근간이 되는 컴포넌트이자 최상위 컴포넌트를 의미한다.

인스턴스와 컴포넌트를 레고에 비유한다면 인스턴스는 레고를 조립하는 기본 판을,
컴포넌트는 레고 블록을 의미한다.

--------------------------------------

뷰 인스턴스

뷰 인스턴스는 뷰로 화면을 개발하기 위해 필수적으로 생성해야 하는 기본 단위입니다.

  * Vue.js Instance는 뷰로 화면을 개발하기 위한 필수 조건!

  1. el 속성으로 뷰 인스턴스가 그려질 지점을 지정
  2. data 속성에 message 속성을 추가하여 값을 정의하면 화면의 {{message}}에 연결 가능

뷰 인스턴스 생성자

  new vue()로 인스턴스를 생성할 때 Vue를 생성자라고 한다.
  Vue 생성자는 뷰 라이브러리를 로딩하고 나면 접근할 수 있다.
  생성자를 사용하는 이유는 뷰로 개발할 떄 필요한 기능들을 생성자에 미리 정의해 놓고
  사용자가 그 기능을 재정의하여 편리하게 사용하도록 하기 위해서 이다.

  * 생성자는 객체를 새로 생성할 때 자주 사용하는 옵션과 기능들을 미리 특정 객체에 저장해 놓고,
    새로 객체를 생성할 때 기존에 포함된 기능과 더불어 기존 기능을 쉽게 확장하여 사용하는 기법이다.

    일반적으로 객체 지향 프로그래밍에서 사용하는 객체 정의 방식으로 미리 정의된 속성과 메서드를 재활용하기 위해 사용한다.

뷰 인스턴스 옵션 속성

  인스턴스를 생성할 때 재정의할 data, el, template 등의 속성을 의미한다.

  뷰 인스턴스로 화면을 렌더링할 때 화면이 그려질 위치의 돔 요소를 지정해 주어야 한다.
  el 속성에서 선택자는 CSS 선택자 규칙과 같다. ( # 와 .)

    template : 화면에 표시할 HTML, CSS 등의 마크업 요소를 정의하는 속성이다.
    methods : 화면 로직 제어와 관계된 메서드를 정의하는 속성이다. 화면의 전반적인 이벤트와 화면 동작과 관련된 로직 추가 가능.
    created : 뷰 인스턴스가 생성되자마자 실행할 로직을 정의할 수 있는 속성이다.

인스턴스가 화면에 적용되는 과정

  1. 뷰 라이브러리 파일 로딩
  2. 인스턴스 객체 생성(옵션 속성 포함 el,data,template,created,methods 등)
  3. 특정 화면 요소에 인스턴스를 붙임
  4. 인스턴스 내용이 화면 요소로 변환
  5. 변화된 화면 요소를 사용자가 최종 확인

* 인스턴스의 유효 범위는 el 속성으로 지정한 요소들로 제한된다.
  예를들어 data 속성이 지정한 요소 바깥에 있으면 뷰에서는 인식하지 못한다.

    ex) {{message}} 그대로 출력되게 된다.

------------------------------------------

뷰 인스턴스 라이프 사이클

  인스턴스의 상태에 따라 호출할 수 있는 속성들을 라이프 사이클(life cycle) 속성이라고 한다.

라이프 사이클 훅

  각 라이프 사이클 속성에서 실행되는 커스텀 로직을 라이프 사이클 훅(hook)이라고 한다.

라이프 사이클 단계

  크게 4단계 : 인스턴스 생성 -> 인스턴스를 화면에 부착 -> 인스턴스 내용 갱신 -> 인스턴스 소멸

  총 8단계 : beforeCreate -> created -> beforeMount -> mounted -> beforeUpdate -> updated -> beforeDestroy -> destroyed

* mounted 단계와 updated 단꼐에서 하위 컴포넌트의 화면 요소와 외부 라이브러리에 의해
  주입된 요소의 최종 변환 시점이 다를 수 있다.
  $nextTick() API 를 이용하여 HTML 코드로 최종 파싱(변환)될 때까지 기다린 후,
  돔 제어 로직을 추가하자.

-------------------------------------------

전역 컴포넌트 - 여러 인스턴스에서 공통으로 사용 가능

  전역 컴포넌트 등록
    Vue.component('컴포넌트 이름', {
      // 컴포넌트 내용
    })

  * 여기서 컴포넌트 이름은 template 속성에서 사용할 HTML 사용자 정의 태그 이름을 의미한다.

지역 컴포넌트 - 특정 인스턴스에서만 유효한 범위를 가짐

  지역 컴포넌트는 전역 컴포넌트 등록과는 다르게 뷰 인스턴스에 components 속성을 추가하고
  등록할 컴포넌트 이름과 내용을 정의한다.

  new Vue({
    components: {
      '컴포넌트 이름': 컴포넌트 내용
    }
  })

  * 컴포넌트 이름은 전역 컴포넌트와 마찬가지로 HTML 등록할 사용자 정의 태그를 의미한다.
    컴포넌트 내용은 컴포넌트 태그가 실제 화면 요소로 변환돨 때의 내용을 의미한다.

전역 컴포넌트는 인스턴스를 새로 생성할 때마다 인스턴스에 components 속성으로 등록할 필요 없이
한 번 등록하면 어느 인스턴스에서든지 사용할 수 있습니다.

반대로 지역 컴포넌트는 새 인스턴스를 생성할 때마다 등록해 줘야 합니다.

---------------------------------------------

뷰 컴포넌트 통신

컴포넌트간 통신과 유효범위

  앵귤러 1이나 백본(Backbone.js)같은 초창기 자바스크립트 프레임워크에서는 한 화면을 1개의 뷰(View)로 간주했다.
  따라서 한 화면의 데이터를 해당 화면 영역 어디서든지 호출할 수 있었음.

  하지만 뷰의 경우 컴포넌트로 화면을 구성하므로 같은 웹 페이지라도 데이터를 공유할 수 없다.

  * 컴포넌트마다 자체적으로 고유한 유효 범위(Scope)를 가지기 때문.
    이는 뷰 프레임워크 내부적으로 정의된 특징이다.
    따라서 각 컴포넌트의 유효 범위가 독립적이기 때문에 다른 컴포넌트의 값을 직접적으로 참조할 수 없다!

    뷰에서 미리 정의해 놓은 데이터 전달 방식에 따라 일관된 구조로 애플리케이션을 작성하게 된다.
    개발자 개개인의 스타일대로 구성되지 않고, 애플리케이션이 모두 동일한 데이터 흐름을 가지므로
    다른 사람의 코드를 빠르게 파악할 수 있고, 협업하기에 좋다!

상/하위 컴포넌트 관계

  뷰 프레임워크 자체에서 정의한 컴포넌트 데이터 전달 방법?

  가장 기본적인 데이터 전달 방법은 바로 상위(부모) - 하위(자식) 컴포넌트 간의 데이터 전달 방법이다.

  상위 - 하위 컴포넌트란 트리 구조에서 부모 노드, 자식 노드처럼 컴포넌트 간의 관계가 부모, 자식으로
  이루어진 컴포넌트를 의미한다.

  * 하위 컴포넌트를 등록한 인스턴스는 상위 컴포넌트(부모 컴포넌트)가 된다.

  상위 -> 하위 - props 전달
  하위 -> 상위 - 이벤트 발생. 이벤트 전달 (이벤트와 함께 데이터를 전달하려면 이벤트 버스를 활용한다.)
                event emit으로 상위 컴포넌트에 신호를 보내면 된다.

  * 뷰는 단방향 데이터 흐름을 사용한다. 상위에서 하위로 데이터를 전달하는 흐름.

  복잡한 뷰 애플리케이션을 구축할 때는 이벤트 버스를 이용하여 하위에서 상위 컴포넌트로 데이터를 전달할
  수도 있다.

상위에서 하위 컴포넌트로 데이터 전달하기

  상위에서 하위로 데이터를 전달할 때는 하위 컴포넌트의 속성에 props를 정의하고,
  상위 컴포넌트의 HTML 코드에 등록된 사용자 정의 컴포넌트 태그에 v-bind 속성을 추가하여 전달한다.

하위에서 상위 컴포넌트로 이벤트 전달하기

  이벤트 발생과 수신은 $emit()과 v-on: 속성을 사용하여 구현한다.

  // 이벤트 발생($emit()을 이용한 이벤트 발생)
  this.$emit('이벤트명');

  // 이벤트 수신(v-on 속성을 이용한 이벤트 수신)
  <child-component v-on:이벤트명="상위 컴포넌트의 메서드명"></child-component>

    호출한 이벤트 명은 하위 컴포넌트를 등록하는 태그(상위 컴포넌트의 template 속성에 위치)에서
    v-on:으로 받는다.
    하위 컴포넌트에서 발생한 이벤트명을 v-on: 속성에 지정하고,
    속성의 값에 이벤트가 발생했을 때 호출될 상위 컴포넌트의 메서드를 지정한다.

  * 일반적으로 $emit()을 호출하는 위치는 하위 컴포넌트의 특정 메서드 내부이다.
    따라서 $emit()을 호출할 때 사용하는 this는 하위 컴포넌트를 가리킨다.

    이와 같은 방식으로
    하위 컴포넌트에서 상위 컴포넌트로 신호를 올려보내면 상위 컴포넌트의 메서드를
    실행할 수도 있고, 하위 컴포넌트로 내려보내는 props의 값을 조정할 수도 있습니다.

관계 없는 컴포넌트 간 통신 - 이벤트 버스

  이벤트 버스를 구현하려면 애플리케이션 로직을 담는 인스턴스와는 별개로 새로운 인스턴스를 1개 더 생성하고,
  생성한 새 인스턴스를 이용하여 이벤트를 보내고 받습니다.

    var eventBus = new Vue()

    보내는 컴포넌트에서는 .$emit()을, 받는 컴포넌트에서는 .$on()을 구현합니다.

  컴포넌트 통신은 항상 상위 - 하위 구조를 유지해야만 데이터를 주고받을 수 있엇지만
  이벤트 버스를 이용하면 같은 레벨의 컴포넌트 사이에서나 하위->상위 방향으로도 데이터 전달이 가능해진다.

  * 이벤트 버스를 활용하면 props 속성을 이용하지 않고도 원하는 컴포넌트 간에 직접적으로 데이터를
    전달할 수 있어 편리하지만 컴포넌트가 많아지면 어디서 어디로 보냈는지 관리가 되지 않는 문제가
    발생합니다. 이 문제를 해결하려면 뷰엑스(Vues)라는 상태 관리 도구가 필요합니다.

  * 뷰엑스는 중, 대형 애플리케이션에서 컴포넌트 간의 데이터 관리를 효율적으로 하는 라이브러리이다.

---------------------------------------------------------------------------------------------

라우터 & HTTP 통신 - 상용 웹 앱을 개발하기 위한 필수 기술들

    상용 웹 앱의 경우 여러 페이지로 구성되어 있기 때문에 페이지 간에 이동을 돕는 라우터를 사용해야 한다.
    또한 사용자에게 의미 있는 데이터를 보여주기 위해 서버에서 데이터를 가져오는 HTTP 통신도 필요하다.

라우팅이란?

  웹 페이지 간의 이동 방법을 말한다. 라우팅은 현대 웹 앱 형태 중 하나인 SPA에서 주로 사용하고 있다.

  * 라우팅을 이용하면 화면을 매끄럽게 전환하고 더 빠르게 화면을 조작 가능하여 사용자 경험이 향상된다.

  * 프런트앤드 프레임워크를 사용하지 않고 일반 HTML 파일들로도 라우팅 자바스크립트 이용하여
    라우팅 방식의 페이지 이동이 구현 가능하다. 대표적으로 router.js, navigo.js 가 있다.

뷰 라우터

  뷰 라우터는 뷰에서 라우팅 기능을 구현할 수 있도록 지원하는 공식 라이브러리이다.
  뷰 라우터를 이용하여 뷰로 만든 페이지 간에 자유롭게 이동이 가능하다.

  - 뷰 라우터 특수 태그 사용법

    <router-link to="URL 값"> - 페이지 이동 태그. 랜더링시 <a>로 변환되어 표시되며 클릭하면
                                to로 지정한 URL에 이동. to=""에 정의된 텍스트 값이
                                브라우저 URL 끝에 추가된다.

    <router-view> - 페이지 표시 태그, 변경되는 URL에 따라 해당 컴포넌트를 뿌려주는 영역이다.
                    나타낼 화면은 <script>에서 정의한다.

    이게 다임!

  - $mount API

    el 속성과 동일하게 인스턴스를 화면에 붙이는 역할을 한다.
    인스턴스를 생성할 때 el 속성을 넣지 않았더라도 생성하고 나서 $mount()를 이용하면
    강제로 인스턴스를 화면에 붙일 수가 있다.

    * 뷰 라우터 공식 문서는 인스턴스 안에 el을 지정하지 않고 라우터만 지정하여 생성한 다음
      생성된 인스턴스를 $mount()를 이용해 붙이는 식으로 안내하고 있다.

  - 라우터 URL의 해시 값(#)을 없애는 방법

      뷰 라우터의 기본 URL 형식은 해시 값을 사용한다.
      index.html/login과 같이 해시 값을 없애려면 히스토리 모드(history mode)를 활용하면 된다.

  - 뷰 라우터 URL의 해시 값을 없애는 속성

      var router = newVueRouter({
        mode: 'history',
        routes
      });

네스티드 라우터

  네스티드 라우터(Nested Router)는 라우터로 페이지를 이동할 때 최소 2개 이상의 컴포넌트를
  화면에 나타낼 수 있다. 네스티드라는 단어에서 추측할 수 있듯이 상위 컴포넌트 1개에
  하위 컴포넌트 1개를 포함하는 구조로 구성하는 것을 말한다.

    ex) domain.com/user - User 컴포넌트
        domain.com/user/posts - User 컴포넌트에 포함되는 Post 컴포넌트
        domain.com/user/profile - 유저 컴포넌트에 포함되는 Profile 컴포넌트

  * 네스티드 라우터와 기본 라우터의 차이점은 최상위(루트) 컴포넌트에도 <router-view>가 있고,
    최상위 컴포넌트의 하위 컴포넌트(User)에도 <router-view>가 있다는 것이다.(템플릿에 있음)
    그렇기 때문에 URL에 따라 하위 컴포넌트 내용이 바뀌게 된다.

    네스티드 라우터는 화면을 구성하는 컴포넌트의 수가 적을 때는 유용하지만 한 번에 더 많은
    컴포넌트를 표시하는 데는 한계가 있다.
    이 문제를 해결할 수 있는 방안으로는 네임드 뷰가 있다.

네임드 뷰(Named View)

  네임드 뷰는 특정 페이지로 이동했을 때 여러 개의 컴포넌트를 동시에 표시하는 라우팅 방식이다.
  네스티드 라우터는 상위 컴포넌트가 하위 컴포넌트를 포함하는 형식이지만,
  네임드 뷰는 같은 레벨에서 여러 개의 컴포넌트를 한 번에 표시한다.

  네스티드 라우터와 다른 점?

    네임드 뷰는 new VueRouter()로 라우터를 하나 생성하고 라우터 정보를 바로 그 안에 정의한다.

    * 네스티드 라우터는 아래의 코드처럼 라우터 정보를 미리 밖에서 정의했었음

      var routes = [
        {
          path: '',
          component: ,
          children: [
            {
              path: '',
              component:
            },
            {
              path: '',
              component:
            },
          ]
        }
      ];

      var router = newVueRouter({
        routes
      });

    * 네임드 뷰는 위의 네스티드 라우터 코드와는 다르게 라우터를 하나 생성하고
      밖이 아닌 라우터 인스턴스 바로 그 안에 정의한다.

  네임드 뷰의 <router-view>에서 name 속성에 사용한 값은 예약어가 아니다.
  즉 사용자가 임의로 정의할 수 있는 값이다.
  다만 예외적으로 name 속성을 지정하지 않았을 때의 기본 컴포넌트는 default로 접근된다.

------------------------------------------------------

HTTP

  HTTP는 브라우저와 서버 간에 데이터를 주고 받는 통신 프로토콜이다.

  브라우저에서 특정 데이터를 보내달라고 요청(request)을 보내면
  서버에서 응답(response)으로 해당 데이터를 보내주는 방식으로 동작한다.

  서버에 '해당 데이터를 보내주세요' 라는 메시지를 보내는 게 바로
  'HTTP 요청을 보낸다'와 같은 의미이다.

웹 앱 HTTP(브라우저와 서버 간에 데이터를 주고 받는 통신 프로토콜)통신의 대표적인 예

  제이쿼리의 ajax. 서버에서 받아온 데이터를 표시할 때 화면 전체를 갱신하지 않고도
  화면의 일부분만 변경할 수 있게 하는 자바스크립트 기법이다.
  대중화되면서 많은 웹 앱에서 ajax를 사용하고 있다.

  뷰에서도 마찬가지로 ajax를 지원하기 위한 라이브러리를 제공한다.
  뷰의 필수 라이브러리였던 뷰 리소스와 요즘 가장 많이 사용하는 액시오스(axios)가 바로 그것이다.

뷰 리소스

  초기에 코어 팀에서 공식적으로 권하는 라이브러리 였으나 2016년 말에 지원을 중단하였다.
  이유는 HTTP 통신 관련 라이브러리는 뷰 라우팅, 상태 관리와 같은 라이브러리와는 다르게
  프레임워크에 필수적인 기능이 아니라고 판단했기 때문이라고 한다.
  그럼에도 불구하고 아직 계속 사용할 수 있는 라이브러리이다.

  - 뷰 리소스 사용법

    1. CDN을 이용해서 라이브러리를 로딩하는 방식
    2. NPM으로 라이브러리를 설치하는 방법(ES6 기준)

  * 뷰 리소스 라이브러리를 이용하여 서버로부터 데이터를 받아와 화면에 나타낼 수 있다.
    현재는 1.5.1버젼인데, Promise API 지원 업데이트가 되어있어서 JSON.parse로 파싱 안해줘도 되나봄

액시오스(Axios)

  현재 뷰 커뮤니티에서 가장 많이 사용되는 HTTP 통신 라이브러리이다. 에반도 뷰 리소스 라이브러리를
  공식 라이브러리에서 제외하면서 액시오스를 언급했다. 많은 개발자들이 관심을 가지고 이용하는 라이브러리이다.
  깃허브 리포지토리 활성화가 잘 되어있어서 뷰 리소스보다 더 안정적으로 지원되는 라이브러리라고 볼 수 있다.

  Promise 기반의 API 형식이 다양하게 제공되어 별도의 로직을 구현할 필요 없이 주어진 API만으로도 간편하게
  원하는 로직을 구현할 수 있다.

  * Promise 기반의 API 형식이란?

    서버에 데이터를 요청하여 받아오는 동작과 같은 비동기 로직 처리에 유용한 자바스크립트 객체이다.
    자바스크립트는 단일 스레드(thread)로 코드를 처리하기 때문에 특정 로직의 처리가 끝날 때 까지 기다려주지 않는다.
    따라서 데이터를 요청하고 받아올 때까지 기다렸다가 화면에 나타내는 로직을 실행해야 할 때 주로 Promise를 활용한다.
    그리고 데이터를 받아왔을 떄 Promise로 데이터를 화면에 표시하거나 연산을 수행하는 등 특정 로직을 수행합니다.
    데이터 통신과 관련한 여러 라이브러리 대부분에서 Promise를 활용하고 있으며, 액시오스에서도 Promise 기반의
    API를 지원합니다.

  API 유형 정리

    * 서버에서 보낸 데이터를 정삭적으로 받아오면 then()안에 정의한 로직이 실행되고,
      데이터를 받아올 때 오류가 발생하면 catch()에 정의한 로직이 수행됩니다.

    HTTP GET 요청 - axios.get('URL 주소').then().catch();

    HTTP POST 요청 - axios.post('URL 주소').then().catch();

    HTTP 요청에 대한 옵션 속성 정의 - 자세한 속성들을 직접 정의하여 보낼 수 있음.
                                    데이터 요청을 보낼 URL, HTTP 요청 방식, 보내는 데이터 유형 등등

      axios({
        method: 'get',
        url: 'URL 주소',
      })

      * JSON.parse()를 사용하여 객체로 변환할 필요가 없다. 즉 역직렬화 할 필요가 없다.
      와이어에서 자바스크립트의 역직렬화를 axios API에서 해주기 때문.

      이처럼 HTTP 통신 라이브러리인 axios에서 제공하는 API를 이용하여
      간편하게 HTTP 통신을 구현할 수 있고, 원하는 데이터를 서버에서 끌어다가
      화면으로 가져올 수 있다! 더 자세한 사용 방법과 가이드는 깃허브 리포지토리를 참고하자.

-------------------------------------------------------

뷰 탬플릿(Template)이란?

  뷰의 탬플릿(Template)은 HTML, CSS등의 마크업 속성과 뷰 인스턴스에서 정의한 데이터 및 로직들을
  연결하여 사용자가 브라우저에서 볼 수 있는 형태의 HTML로 변환해 주는 속성이다.

  탬플릿에서 사용하는 뷰의 속성과 문법

    - 데이터 바인딩
    - 자바스크립트 표현식
    - 디렉티브
    - 이벤트 처리
    - 고급 탬플릿 기법

    1. 데이터 바인딩

    데이터 바인딩은 HTML 화면 요소를 뷰 인스턴스의 데이터와 연결하는 것을 의미한다.
    주요 문법으로는 {{}} 콧수염 괄호 문법과 v-bind 속성이 있다.

    {{}}는 뷰 인스턴스의 데이터를 HTML 태그에 연결하는 가장 기본적인 텍스트 삽입 방식이다.
    {{}} Mustache 는 뷰 뿐만 아니라 다른 언어나 프레임 워크에서도 자주 사용되는 탬플릿 문법이다.

    * 뷰 데이터가 변경되어도 값을 바꾸고 싶지 않다면?

      <div id="app" v-once>
        {{ message }}
      </div>

      위와 같이 v-once 속성을 사용해주자.

    v-bind는 아이디, 클래스, 스타일 등의 HTML 속성(attributes) 값에 뷰 데이터 값을 연결할 때
    사용하는 데이터 연결 방식이다. 지정할 HTML 속성이나 props 속성 앞에 접두사로 붙여준다.

    v-bind 문법 :로 간소화 가능 ex) v-bind:id 는 :id 와 같다.

      가급적이면 v-bind 속성을 이용하는 것이 좋다.
      기존 HTML문법과 구분도 되고 다른 사람이 코드를 파악하기 쉽기 때문

    2. 자바스크립트 표현식

      뷰의 템플릿에서도 자바스크립트 표현식을 쓸 수 있다. 데이터 바인딩 방법 중 하나인
      {{}} 안에 자바스크립트 표현식을 넣으면 된다.

      * 주의점

        - 자바스크립트의 선언문과 분기 구문은 사용할 수 없다.

        - 복잡한 연산은 인스턴스 안에서 처리하고 화면에는 간단한 연산 결과만 표시해야 한다.

          HTML단에서 수행하지 않고, 자바스크립트 단에서 computed 속성을 이용하여 계산한 후
          최종 결과 값만 표시하도록 하자. 뷰에서 이러한 방식을 권하는 이유는 HTML에 최종적으로
          표현될 값만 나타내고, 데이터의 기본 연산은 자바스크립트 단에서 함으로써 화면단 코드의
          가독성을 높일 수 있기 때문이다. 이렇게 되면 화면단 코드를 훨씬 빠르게 읽을 수 있어
          화면의 UI 구조를 쉽게 파악할 수 있다.
          분기 구문과 동일한 로직을 처리하고 싶으면 자바스크립트의 삼항 연산자를 사용해야 한다.

          또한 computed 속성을 이용하여 반복적인 연산에 대해서는 미리 계산하여 저장해 놓고,
          필요할 때 바로 불러오는 캐싱(caching) 효과를 얻을 수 있다.

          캐싱이란 데이터나 값을 임시 장소에 미리 복사해 놓는 동작이다.
          해당 값을 임시 장소에 저장해 놓고 필요할 때 바로 불러올 수 있기 때문에
          수행시간이 훨씬 빠르다.

      * 삼항연산자

          조건 ? 식1 : 식2    조건이 참이면 식 1을 반환하고, 거짓이면 식 2를 반환한다.

    3. 디렉티브( Directive - 지시자)

      뷰 디렉티브(Directive)란 HTML 태그 안에 v- 접두사를 가지는 모든 속성들을 의미한다.
      v-bind 속성도 Directive에 해당된다.

      * 디렉티브 형식 예시

        <a v-if="hou">호우 날두</a>

        뷰 인스턴스 데이터 속성에 정의된 hou 값에 따라 보이기도 하고 안보이기도 한다.

      디렉티브는 화면의 요소를 더 쉽게 조작하기 위해 사용하는 기능이다.
      뷰의 데이터 값이 변경되었을 때 화면의 요소들이 Reactive하게 반응하여 변경된
      데이터 값에 따라 갱신된다. 이런식으로 화면의 요소를 직접 제어할 필요 없이
      뷰의 디렉티브를 활용하여 화면 요소들을 조작할 수 있다.
      (앵귤러나 리액트에서도 프레임워크 자체적으로 화면 요소를 조작한다.)

      주요 디렉티브들

        v-if

          지정한 뷰 데이터의 값의 참, 거짓 여부에 따라 해당 HTML 태그를 화면에 표시하거나
          표시하지 않는다.

        v-for

          지정한 뷰 데이터의 개수만큼 해당 HTML 태그를 반복 출력한다.

        v-show

          v-if와 유사하게 데이터의 진위 여부에 따라 해당 HTML 태그를 화면에 표시하거나 표시하지 않는다.
          다만, v-if는 해당 태그를 완전히 삭제하지만 v-show는 css 효과만 display:none;으로 주어
          실제 태그는 남아 있고 화면상으로만 보이지 않는다.

        v-bind

          HTML 태그의 기본 속성과 뷰 데이터 속성을 연결한다.

        v-on

          화면 요소의 이벤트를 감지하여 처리할 때 사용한다. 예를 들어, v-on:click은 해당 태그의
          클릭 이벤트를 감지하여 특정 메서드를 실행할 수 있다.

        v-model

          폼(form)에서 주로 사용되는 속성이다. 폼에 입력한 값을 뷰 인스턴스의 데이터와 즉시 동기화 한다.
          화면에 입력된 값을 저장하여 서버에 보내거나 watch와 같은 고급 속성을 이용하여 추가 로직을
          수행할 수 있다. <input>, <select>, <textarea> 태그에만 사용할 수 있다.

          - v-model 디렉티브는 앵귤러의 양방향 데이터 바인딩을 본따 만든 뷰의 기능이다.
            앵귤러와 동일한 방식으로 화면단의 데이터를 스크립트단의 특정 데이터와 일치시켜 준다.

      * 앵귤러 디렉티브, 뷰 디렉티브

        공통점 - 개발자가 돔 요소를 직접 제어하지 않고 프레임워크에 돔 요소 제어 권한을 위임한다.
                 필요에 따라 개발자가 직접 돔 요소에 접근할 수는 있지만 프레임워크에서는 권장하지 않는다.
                 또한 앵귤러나 뷰 모두 형식과 기능을 직접 제작해서 사용할 수 있다.

    4. 이벤트 처리

      화면에서 발생한 이벤트를 처리하기 위해 v-on 디렉티브와 methods 속성을 활용한다.

      * 아래처럼 인자도 넘길 수 있다.

        <button v-on:click="clickBtn(10)">클릭</button>

        <script>
          methods: {
            clickBtn: function(num) {
              alert('clicked ' + num + ' times');
            }
          }
        </script>

      * event 인자를 이용해 화면 요소의 돔 이벤트에 접근할 수 있다.

        <button v-on:click="clickBtn">클릭</button>

        <script>
          methods: {
            clickBtn: function(event) {
              console.log(event);
            }
          }
        </script>

        HTML에서 v-on:click으로 호출되는 메서드에 인자를 전달하지 않아도
        clickBtn:function(event) { }와 같이 event 인자를 정의하면 해당 돔 요소의
        이벤트 객체에 접근할 수 있다.

        위 코드를 실행하고 [클릭] 버튼을 클릭하면 마우스 이벤트 객체가 콘솔에 출력될 것이다.

    5. 고급 템플릿 기법

      실제 애플리케이션을 개발할 때 유용한 속성으로 데이터 바인딩,
      디렉티브 같은 기본적인 문법과 함께 사용한다.

      computed 속성

        데이터 연산들을 정의하는 영역이다.
        데이터를 가공하는 등의 복잡한 연산은 뷰 인스턴스 안에 하고 최종적으로 HTML에는
        데이터를 표현만 해야한다.

        computed 속성의 장점

        - data 속성 값의 변화에 따라 자동으로 다시 연산한다는 점이 장점이다.
          computed 속성에서 사용하고 있는 data 속성 값이 변경되면 전체 값을 다시 한번 계산한다.

        - 동일한 연산을 반복해서 하지 않기 위해 연산의 결과 값을 미리 저장했다가 필요할 때 불러오는
          동작인 캐싱이 장점이다. 미리 연산한 결과를 가지고 있다가 화면에 결과만 표시한다.


        computed 속성과 methods 속성의 차이점

          가장 큰 차이점은 methods 속성은 호출할 때만 해당 로직이 수행되고,(수동적)
          computed 속성은 대상 데이터의 값이 변경되면 자동적으로 수행된다는 것이다.(능동적)

          수동적으로 데이터를 갱신하느냐, 능동적으로 데이터를 갱신하느냐의 차이점이 있다.
          methods 속성은 수행할 때마다 연산을 하기 때문에 별도로 캐싱을 하지 않지만,
          computed 속성은 데이터가 변경되지 않는 한 이전의 계산 값을 가지고 있다가(캐싱하고 있다가)
          필요할 때 바로 반환해준다.

          복잡한 연산을 반복 수행해서 화면에 나타내야 한다면 computed 속성보단 methods 속성이다.
          성능면에서 더 효율적이다.

      watch 속성

        데이터 변화를 감지하여 자동으로 특정 로직을 수행한다.
        computed 속성과 유사하지만 computed 속성은 내장 API를 활용한 간단한 연산 정도로
        적합한 반면에, watch 속성은 데이터 호출과 같이 시간이 상대적으로 더 많이 소모되는
        비동기 처리에 적합하다.

        * Promise는 자바스크립트 비동기 처리에 사용되는 객체이다.

        * 자바스크립트의 비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고
          다음 코드를 먼저 실행하는 자바스크립트의 특성을 의미한다. (특징 - 단일 스레드)

        * 특정 로직의 실행이 끝날 때까지 기다려주지 않고 나머지 코드를 먼저 실행하는 것이 비동기 처리이다.

            자바스크립트에서 비동기 처리가 필요한 이유를 생각해보면, 화면에서 서버로 데이터를 요청했을 때
            서버가 언제 그 요청에 대한 응답을 줄지도 모르는데 마냥 다른 코드를 실행 안 하고 기다릴 순 없기 때문.

            대표적인 사례로는 jQuery의 ajax와 Web API인 setTimeout()이 있다.

        * 콜백 함수를 사용하면 특정 로직이 끝났을 때 원하는 동작을 실행시킬 수 있다.

          콜백 지옥? (Callback hell ?)

            웹 서비스를 개발하다 보면 서버에서 데이터를 받아와 화면에 표시하기까지 인코딩,
            사용자 인증 등을 처리해야 하는 경우가 있다. 만약 이 모든 과정을 비동기로 처리해야 한다고 하면
            콜백 안에 콜백을 계속 무는 형식으로 코딩을 하게 된다. 이러한 코드 구조는 가독성도 떨어지고
            로직을 변경하기도 어렵다. 이와 같은 코드 구조를 콜백 지옥이라고 한다.

            - 일반적으로 콜백 지옥을 해결하는 방법에는 Promise나 Async를 사용하는 방법이 있다.
              코딩 패턴으로만 콜백 지옥을 해결하려면 각 콜백 함수를 분리해주면 된다.
              즉 중첩해서 선언했던 콜백 익명 함수들을 각각의 함수로 구분하면 개선된다.

              function parseValueDone(id) {
	             auth(id, authDone);
              }
              function authDone(result) {
	             display(result, displayDone);
              }
              function displayDone(text) {
	              console.log(text);
              }
              $.get('url', function (response) {
	               parseValue(response, parseValueDone);
              });

              위와 같은 코딩 패턴으로도 콜백 지옥을 해결할 수 있지만,
              Promise나 Async를 이용하면 더 편하게 구현할 수 있다.

        watch 속성의 예

        - input 태그에 v-model 디렉티브로 연결하여 입력 값에 변화가 있을 때마다
          뷰 인스턴스의 watch속성에서 변화된 값을 로그로 출력한다.

------------------------------------------------------------------

뷰 프로젝트 구성 방법

  HTML 파일에서 뷰 코드 작성 시의 한계점

    - 화면에 표시될 모양을 미리 예측하기 어렵다.
    - 상위 태그와 하위 태그의 관계를 파악하기 어렵다.
    - 오타를 찾기 어렵다.
    - 태그 구조 파악도 어렵다. CSS시트나 인라인 스타일을 적용하는 것도 어려워진다.

  싱글 파일 컴포넌트 체계

    위의 문제점을 해결하는 방법이 바로 싱글 파일 컴포넌트(Single File Components) 체계이다.
    .vue 파일로 프로젝트 구조를 구성하는 방식을 말한다.
    확장자 .vue 파일 1개는 뷰 애플리케이션을 구성하는 1개의 컴포넌트와 동일하다.

  웹팩?

    웹팩은 웹 앱의 자원(HTML, CSS, 이미지)들을 자바스크립트 모듈로 변환해 하나로 묶어
    웹 성능을 향상시켜 주는 자바스크립트 모듈 번들러이다.
    브라우저리파이도 웹팩과 유사하지만 웹팩과는 다르게 웹 자원 압축이나
    빌드 자동화 같은 기능이 없다.

  뷰 CLI 명령어

    npm install vue-cli -global

      뷰 CLI 전역 설치

    vue init webpack

      고급 웹팩 기능을 활용한 프로젝트 구성 방식. 테스팅, 문법 검사(엄격)등을 지원

    vue init webpack-simple

      웹팩 최소 기능을 활용한 프로젝트 구성 방식. 빠른 화면 프로토타이핑용

    vue init browserify

      고급 브라우저리파이 기능을 활용한 프로젝트 구성 방식.
      웹팩처럼 최소 기능 빠른 화면 프로토 타이핑용 browserify-simple 명령어도 있다.

    vue init simple

      최소 뷰 기능만 들어간 HTML 파일 1개 생성

    vue init pwa

      웹팩 기반의 프로그레시브 웹 앱(PWA, Progressive Web App) 기능을 지원하는
      뷰 프로젝트

  * 웹팩이나 브라우저리파이 같은 모듈 번들러를 프로젝트 자체에 포함하여 바로 사용할 수 있다.

  * .vue 파일을 HTML, CSS, 자바스크립트 파일로 변환해 주기 위한 뷰 로더(Vue Loader)를 포함하고 있다.
    즉 .vue 파일 방식으로 애플리케이션을 개발하려면 뷰 로더와 이를 지원하는 웹팩, 브라우저리파이 같은
    모듈 번들러가 필요하다.

  * 뷰 프레임워크 자체에 집중할 수 있는 템플릿은 webpack-simple이다.
    webpack 템플릿은 웹팩의 여러 가지 기능과 테스팅 라이브러리, 문법 검사 라이브러리를 모두 포함하고 있기 때문에
    프로젝트 구성 방식을 파악하는데 상당한 시간이 소요된다. + 까다로운 문법 검사로 인해 화면을 빠르게 구현하기 어려움.

  * webpack-simple 템플릿은 뷰로 개발하기 위한 웹팩의 최소 기능들만 있어 프로젝트 구성 자체가 간단하다.

    vue init 명령어로 프로젝트를 생설할 때 package.json 파일도 함께 생성된다.
    package.json 파일은 프로젝트 정보를 담고 있는 설정 파일임과 동시에 npm 명령어 및 뷰로 애플리케이션을 제작하는 데
    필요한 라이브러리 정보들을 포함하고 있다.

    npm install 명령어를 실행하면 package.json의 라이브러리 목록이 전부 프로젝트의 node_modules 폴더 밑에 설치된다.
    웹팩을 빌드하기 위한 바벨(Babel) 및 여러 가지 로더, 웹팩 dev 서버 등의 라이브러리와 뷰를 구현하기 위한
    뷰 코어 라이브러리 등이 설치된다.

  * 윈도우의 경우 CMD창을 관리자 권한으로 실행해야 한다.

  뷰 로더

    뷰 로더(Vue Loader)는 웹팩에서 지원하는 라이브러리이다. 싱글 파일 컴포넌트 체계에서 사용하는
    .vue 파일의 내용을 브라우저에서 실행 가능한 웹 페이지의 형태로 변환해준다.

    예 ) App.vue 파일에서 <template>, <script>, <style>의 내용이 각각 HTML, 자바스크립트, CSS 코드로
        인식될 수 있도록 뷰 로더가 변환 작업을 수행한다.

        이 변환 기능은 웹팩에서 맡고 있다.
        웹팩은 자바스크립트 모듈만 인식할 수 있기 때문에 뷰 로더가 .vue 파일을 일단 자바스크립트 모듈시스템으로 변환한다.
        하지만 필요에 따라 웹팩의 추가 플러그인을 이용하면 웹팩으로 변환된 자바스크립트 모듈을 CSS나 HTML 파일로 분리할 수 있다.

    * 프로젝트 폴더 내의 어느 위치든 .vue 파일을 생성할 수 있지만 체계적인 프로젝트 폴더 구조를 위해
      일반적으로 src 폴더 밑에 컴포넌트(.vue) 파일을 배치한다.

      뷰 CLI로 생성된 프로젝트 폴더의 모든 .vue 파일에 뷰 로더가 적용된다.

  뷰 CLI로 프로젝트를 구성하는 과정

    1. 뷰 CLI 설치

      npm i vue-cli -g

    2. 프로젝트 생성

      vue init webpack-simple

    3. 관련 라이브러리 설치(package.json에 라이브러리가 정의되어있음)

      npm install

    4. 프로젝트 구동

      npm run dev

    끝!

------------------------------

* 뷰 로더에서 <style scoped> 는 범위를 가지는 CSS를 의미한다.
  뷰에서 지원하는 속성이며, 스타일 정의를 해당 컴포넌트에만 적용하겠다는 의미이다.

* 컴포넌트의 data 속성은 꼭 함수로 작성해야한다.
  Vue 인스턴스를 만들 때와 다른점은 data 부분이다. 컴포넌트는 재사용이 가능하기 때문에
  고유한 데이터를 가지고 있어야 한다. 그래서 매번 함수를 실행한 결과 새로운 객체를 반환하도록 했다.
  (Vue 인스턴스에서는 객체를 할당했다)

  data속성은 뷰 인스턴스에서는 객체를 할당, 컴포넌트에서는 객체를 반환 해야 한다.

--------------------------------

로컬 스토리지에 저장하기

  setItem() API를 이용하여 저장가능.
  API 형식은 키, 값 형태

    localStorage.setItem(키,값);

* 크롬 개발자 도구의 Application -> Local Storage -> 로컬호스트 주소에서 확인이 가능하다.

--------------------------------

Javascript Short-Circuite Evaluation(단축 평가 값)

  논리 연산자들은 왼쪽->오른쪽 순으로 실행됨.
  이 연산자들은 결과를 얻게 되는 순간 단축 평가(즉, 평가의 중단)를 시행.
  false && 표현식 -> 이미 false발견
  true || 표현식 -> 이미 true
  그러나 그 결과값은 (반드시 true 또는 false가 아니라) 평가를 중단하게 된 계기가 된 값을 리턴한다.

단축 평가 (Short-Circuit Evaluation)

  논리연산자가 Boolean 값과 함께 사용되지 않을 경우, Boolean 값을 반환하지 않을 수 있다.
  이는 논리 연산자가 피연산자 중 하나를 반환하기 때문이다.
  논리연산자는 다음의 규칙을 따라서 “단축 평가”로 검사된다.

  평가식	평가 결과

    true || anything	true
    false || anything	anything
    true && anything	anything
    false && anything	false

    - 평가를 중지하게된 계기가 된 값을 반환한다.

!!

  !!의 역할은 피연산자를 불린값으로 변환하는 것이다.

  console.log(!!1);         // true
  console.log(!!0);         // false
  console.log(!!'string');  // true
  console.log(!!'');        // false
  console.log(!!null);      // false
  console.log(!!undefined); // false
  console.log(!!{});        // true
  console.log(!![]);        // true

  객체(배열 포함)의 경우 빈 객체라도 존재하기만하면 true로 변환된다.

  객체의 존재 확인 후 그 결과를 반환해야 하는 경우,
  !!를 사용하면 강제로 피연산자를 boolean으로 형 변환 할 수 있다.

디자인 패턴:단일 책임 원칙

  단일 책임 원칙이란 함수 하나가 하나의 기능만 담당하도록 설계하는
  객체 지향 프로그래밍의 디자인 패턴이다.
  함수 안에 여러 기능을 넣을 수도 있지만, 단일 책임 원칙에 따라
  저장이면 저장, 내용 삭제면 삭제 등 하나하나 기능을 나누어서 설계한다.

----------

CSS 참고

vertical-align

  인라인 태그만 먹는다고 한다. 수직정렬 관련. 아이콘의 수직 정렬에 이용되는 듯 하다.

-----------------------------

로컬 스토리지 (HTML5 Web API - localStorage)

  html5에서는 좀 더 쉽고 간단한 저장소 제공을 위해 새로운 localStorage와 sessionStorage api를 제공한다.
  이 둘의 가장 큰 차이점이라면 저장소로서의 기능은 대부분 동일하며 단지 sessionStorage의 경우
  세션이 종료되면 저장된 데이터도 함께 사라진 다는 점이 다른 점이다. 키, 값 형태로 저장한다.

Flex box 3분 컷

  https://joshuajangblog.wordpress.com/2016/09/19/learn-css-flexbox-in-3mins/

-------------------------------

* 뷰의 v-for 디렉티브에서는 index 변수를 기본적으로 제공한다.
  v-for 디렉티브로 반복한 요소는 모두 뷰에서 내부적으로 인덱스를 부여한다.
  (이거 정말 끝내주는군)

-------------------------------

splice()는 자바스크립트에 기본적으로 내장되어 있는 API이다.
배열의 특정 인덱스에서 부여한 숫자만큼의 인덱스를 삭제한다.
일반적으로 자바스크립트 배열 프로그래밍에서 삭제할 때 자주 사용하는 API이니
꼭 알아두자!

----------------------------

데이터의 속성이 변하면 화면에 즉시 반영하는 뷰의 반응성!

---------------------------

뷰 애플리케이션 구조의 문제점 해결하기

  화면을 여러개의 영역(컴포넌트)로 분리해 놓았을 경우 한 영역의 처리 결과를
  다른 영역에서 감지하지 못한다는 문제가 있다.

  이 문제점을 해결하는 가장 간단한 방법은 한 컴포넌트 안에서 데이터 CRUD를 모두 처리하는
  것이다. 하지만 웹 앱이 커질수록 컴포넌트의 개수도 많아지는 것은 불가피하다.
  따라서 컴포넌트 구조화와 통신 방법을 익히지 않으면 간단한 화면은 물론이고
  컴포넌트가 복잡해졌을 때는 구현하기가 더 어려워진다.
  컴포넌트의 단위가 작을수록 재활용성이 높아진다는 컴포넌트의 활용 측면도 중요하지만,
  간단한 애플리케이션에서도 컴포넌트 통신을 할 수 있어야 향후에 스스로 애플리케이션을
  설계하고 구현할 수 있다.

  즉 컴포넌트 통신을 이용하여 해결한다!

* props와 이벤트 전달을 이용해 개선하도록 하자.

------------------------------

데이터와 이벤트의 흐름 이해

  - Todo 앱 적용사례

    하위 컴포넌트인 TodoList에 propsdata로 앱(상위) 컴포넌트의 데이터 전달,
    하위 컴포넌트 TodoList.vue에서 이벤트 전달 -> 상위 컴포넌트인 App.vue에서 이벤트 수신.
    v-bind:하위 컴포넌트 에서 전달받을 propsdata명="상위에서 전달할 데이터"
    v-on:하위 컴포넌트에서 보낸 이벤트명="이벤트를 처리할 상위 컴포넌트 메소드 명"

프로젝트 작성 방법

  - 하위 컴포넌트들은 그 데이터를 표현하거나 데이터 조작에 대한 요청(이벤트 발생)만 하자.

  - 데이터는 모두 App 컴포넌트에서 관리한다. CRUD를 모두 App 컴포넌트에서 처리하자!

--------------------------------

$emit() API 형식과 전달 인자의 규칙

하위 컴포넌트에서 이벤트를 발생시켜 상위 컴포넌트로 신호를 보낼 때 $emit()을 사용한다.
API의 기본 형식은 $emit('이벤트 이름')이지만 $emit('이벤트 이름', 인자1, 인자2, ...)와 같은
형식으로 하위 컴포넌트의 특정 데이터를 전달할 수 있다. 다만 전달받은 인자 값은 상위 컴포넌트에서
참고용으로만 활용하고, 데이터 값은 변경하지 말아야 한다.

  왜?

  * 컴포넌트는 각자 고유한 유효 범위를 갖기 때문에 상위 컴포넌트에서 전달받은 인자 값을 갱신하더라도
    하위 컴포넌트에는 반영되지 않는다. 이런 이유 때문이다!

------------------------------------

* 컴포넌트가 분리되어 데이터를 공유하지 못했던 문제점을 컴포넌트 통신 방법(props 속성, 이벤트 전달)로 해결!

-----------------------------------

생성자 객체의 옵션을 제공하는 대신 Vue 인스턴스를 작성한 후 DOM 요소에 마운트하는 방법

  const vm = new Vue({
    data: {
      name: 'Application'
    },
    template: '<h1>Welcome to {{ name }}</h1>'
  }).$mount('body')

  Vue.js 인스턴스의 메서드가 DOM에 마운트한다.

--------------------------------------

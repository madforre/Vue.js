Vue.js란 무엇인가?

    Vue(/vjuː/ 로 발음, view 와 발음이 같습니다.)는 
    사용자 인터페이스를 만들기 위한 진보적인 프레임워크 입니다. 
    다른 단일형 프레임워크와 달리 Vue는 점진적으로 채택할 수 있도록 
    설계하였습니다. 핵심 라이브러리는 뷰 레이어만 초점을 맞추어 
    다른 라이브러리나 기존 프로젝트와의 통합이 매우 쉽습니다. 
    그리고 Vue는 현대적 도구 및 지원하는 라이브러리와 함께 사용한다면 
    정교한 단일 페이지 응용프로그램을 완벽하게 지원할 수 있습니다.

호환성 정보

    Vue는 ECMAScript 5 기능을 사용하기 때문에 
    IE8 이하 버전을 지원하지 않습니다. 
    하지만 모든 ECMAScript 5 호환 브라우저를 지원합니다.

Vue Devtools

    Vue를 사용할 때, 브라우저에 Vue Devtools를 설치하세요. 
    Vue 앱을 보다 사용자 친화적으로 검사하고 디버그할 수 있습니다.

직접 <script>에 추가

    다운로드 받아 script 태그에 추가하기만 하면 됩니다.
    Vue는 전역 변수로 등록됩니다.

    (개발 중에는 최소화 버젼을 사용하지 마십시오. 일반적인 실수에
    대한 모든 훌륭한 경고를 놓치게됩니다!)    
    
    *개발중에는 개발용 버젼을 사용하자(디버그 제공)
    배포용 버젼은 경고가 제거된다.(최소화 버젼)

NPM

    Vue로 대규모 응용 프로그램을 빌드할 때 NPM을 권장합니다.
    Webpack 또는 Browserify와 같은 모듈 번들러와 잘 작동합니다.
    Vue는 싱글 파일 컴포넌트를 만들기 위한 도구도 제공합니다.

        npm install Vue

CLI

    Vue.js는 단일 페이지 응용 프로그램을 빠르게 스캐폴딩하기 위한 공식
    CLI를 제공합니다. 현대적인 프론트엔드 워크플로우를 위해 잘 구성된
    빌드 설정을 제공합니다. 핫 리로드, lint-on-save 및 프로덕션 준비가 된
    빌드로 시작하고 실행하는데 몇 분 밖에 걸리지 않습니다.

        npm install --global vue-cli

        vue init webpack my-project

        cd my-project

        npm install

        npm run dev

기타 - package.json 생성

    package.json을 생성하려면 프로젝트 루트에서 npm init
    명령어를 실행한다.

    npm init 명령어를 사용하면 프로젝트에 대한 여러 가지 정보를 
    입력하도록 요구받는다. 

기타 - 나이트왓치

    나이트왓치는 노드 기반의 E2E 테스트 프레임워크다. 
    (배보다 배꼽이 더 큰 경우가 발생할 수 있음.)
    충분한 전문성과 기회비용을 필요로 한다.

각 다른 빌드간 차이점

            	    UMD           	CommonJS	            ES Module

Full    	        vue.js	        vue.common.js	        vue.esm.js

Runtime-only	    vue.runtime.js  vue.runtime.common.js	vue.runtime.esm.js

Full (production)	vue.min.js	        -	                    -

Runtime-only        vue.runtime.min.js	-	                    -
(production)	

    AMD(Asynchronous Module Definition)

        비동기 모듈 정의(AMD) 포맷은 브라우저에서
        사용되고 define 함수를 사용해서 모듈을 정의한다.

    UMD(Universal Module Definition)

        만능 모듈 정의(UMD)로, 브라우저와 Node.js에서
        둘 다 사용될 수 있다.

    CommonJS 포맷

        Node.js에서 사용되고 require와 module.exports
        를 사용해서 의존성과 모듈을 정의한다.

    ES6 모듈 포맷
    
        ES6에서 자바스크립트는 내장된 모듈 포맷도 지원한다.

        모듈의 공개 API로 내보내기 위해 export 토큰을 사용한다.
        import는 모듈이 내보내는 부분을 가져온다.
        as를 사용하여 가져오는 모듈에 별명을 줄 수도 있다.
        전체 모듈을 한 번에 로드할 수도 있다. (* 사용)
        default export도 지원한다. (사용하면 모듈을 가져올 때
        괄호 {}를 사용하지 않아도 되며, 단일 값을 내보낼 때 사용한다.)
        함수 뿐만 아니라 어떤 것이든 내보낼 수 있다.
        불행하게도 내장된 모듈 포맷은 아직 모든 브라우저에서 지원되지
        않는다.
        그래서 우리는 이미 ES6 모듈 포맷을 사용할 수 있지만,
        브라우저에서 코드를 실행하기 전에 Babel과 같은
        변환기를 사용해 ES5 모듈 포맷(AMD 또는 CommonJS)로 코드
        변환이 필요하다.

    모듈 로더

        모듈 로더는 주요 모듈 포맷으로 작성된 모듈을 해석하고 로드한다.
        모듈 로더는 런타임에 실행된다.

        - 브라우저에서 모듈 로더를 로드한다.
        - 모듈 로더에게 어떤 메인 애플리케이션 파일을 로드할 것인지 알려준다.
        - 모듈 로더는 메인 애플리케이션 파일을 다운로드하고 해석한다.
        - 필요한 경우 모듈 로더가 파일을 다운로드한다.

        브라우저 개발자 콘솔에서 네트워크 탭을 열면, 모듈 로더에 의해
        많은 파일들이 로드된 것을 볼 수 있다.

        인기 있는 모듈 로더로는 RequireJs, SystemJS 가 있다.

    모듈 번들러

        모듈 번들러는 모듈 로더를 대체한다.

        모듈 로더와 반대로 모듈 번들러는 빌드 타임에 실행된다.

        - 빌드 타임에 번들 파일을 생성하기 위해 모듈 번들러를 실행한다.
          (예:bundle.js)
        - 브라우저에서 번들 파일을 로드한다.

        브라우저 개발자 콘솔에서 네트워크 탭을 열면, 모듈 로더에 의해
        1개 파일만 로드된 것을 볼 수 있다.
        브라우저에서 모듈 로더를 필요로 하지 않는다.
        모든 코드는 번들 안에 포함되어 있다.
        
        인기 있는 모듈 번들에는 다음과 같은 것들이 있다.

        - Browserify : CommonJS 모듈을 위한 번들러
        - Webpack : AMD, CommonJS, ES6 모듈을 위한 번들러

    요약

        모던 자바스크립트 개발 환경에서 툴링을 잘 이해하기 위해서는
        모듈, 모듈 포맷, 모듈 로더와 모듈 번들러 사이의 차이를
        이해하는 것이 중요하다.

        모듈은 구현 세부 사항을 캡슐화하고 공개 API를 노출해
        다른 코드에서 쉽게 로드하고 사용할 수 있도록
        재사용 가능한 코드 조각이다.

        모듈 포맷은 모듈을 정의하기 위해 사용하는 문법이다.
        AMD, CommonJS, UMD, System.register 와 같은
        여러 모듈 포맷이 과거에 등장했으며, ES6부터 내장된 모듈
        포맷을 사용할 수 있다.

        모듈 로더는 주요 모듈 포맷으로 작성된 모듈을 런타임 때
        로드하고 해석한다. RequireJS와 SystemJS가 있다.

        모듈 번들러는 모듈 로더를 대체하고 빌드 타임에 모든 코드의
        번들을 생성한다. Browserify와 Webpack이 있다.

        참조 : https://github.com/codepink/codepink.github.com/wiki/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88,-%EB%AA%A8%EB%93%88-%ED%8F%AC%EB%A7%B7,-%EB%AA%A8%EB%93%88-%EB%A1%9C%EB%8D%94%EC%99%80-%EB%AA%A8%EB%93%88-%EB%B2%88%EB%93%A4%EB%9F%AC%EC%97%90-%EB%8C%80%ED%95%9C-10%EB%B6%84-%EC%9E%85%EB%AC%B8%EC%84%

자바스크립트 모듈 사용의 배경

    자바스크립트는 파이썬, 루비, 다른 스크립트 언어 계열과 차이점이 존재한다.
    바로 모듈 사용의 표준이 존재하지 않다는 것이다. (ECMA5 기준)

    Node.js를 사용하고 있는 개발자들은 module.exports를 통해 
    모듈을 정의하고 require() 함수를 통해 정의한 모듈을 불러와 
    사용하고 있다. 이러한 방식을 CommonJS라고 부른다.

    Node.js 모듈 형태를 보면 다른언어에 비해 모듈제공이 조금 차이가 있다.
    module.exports와 exports 두개를 사용하는데
    이런 제공방식은 혼동을 초래하기도 한다.
    문제는 프론트엔드에서는 이런 모듈 제공방식이 없었다는 것이다!

    프론트엔드에서 사용하는 자바스크립트는 DOM 오브젝트를 사용하고 있다.
    전역 오브젝트인 window를 사용하면 다른 자바스크립트 파일에 
    리소스를 전달 할 수 있다.

    하지만 이것도 사용하는 HTML에서 불러오는 모듈 파일을 먼저 로드해야
    문제가 없이 작동된다.

    즉 대상 모듈이 존재 할 수도, 존재하지 않을 수도 있는 상태가 벌어진다. 
    (으아아악!)

    하지만 프론트엔드에서 사용하는 프로젝트도 규모 커지면 커질수록 
    모듈의 필요성은 커져갔고 그렇게 AMD 방식과 CommonJS 방식 두개의 
    모듈 정의 규칙이 생기게 되었다.

    사실 두개 말고도 ES2016, ES6, System.register 등등의 
    모듈제공 방식도 있지만 여러분의 정신건강을 위해 비밀로한다.
    (밑에서 나올 내용)

동적 로딩이란? (Dynamic Loading)

    실행 시간동안 애플리케이션이 클래스를 로딩하는 것을 의미한다.    
    정적로딩은 미리 메모리를 잡아놓고 사용하고
    동적로딩은 필요할때 메모리를 잡아서 사용하는 것이다. 

AMD
    
    AMD는 Asynchronous Module Definition (비동기 모듈 정의) 규칙이다.

    브라우저에서 모듈을 정의하고 불러오는 기능을 사용하기 위해서는
    AMD의 규칙을 따르는 도구를 사용해야 하는데,
    RequireJS를 사용해보자.

    비동기식 모듈 정의 ( AMD ) API는 모듈 및 그 종속성을 
    비동기 적으로로드 할 수 있도록 모듈을 정의하는 메커니즘을 지정합니다. 
    이것은 모듈의 동기 로딩이 성능, 유용성, 디버깅 및 도메인 간 
    액세스 문제를 유발하는 브라우저 환경에 특히 적합합니다.

기타 -

    AMD와 CommonJS 둘 모두 프론트엔드 브라우저에서 동적 로딩을 할 경우
    페이지가 열리기 전까지 수많은 JS를 사용자가 페이지를 열어볼 때 
    불러오므로 부하가 발생하게 된다. (캐시를 해도 느린건 마찬가지)
    몇 백개의 자바스크립트를 매 사용자가 페이지를 전환할 때마다
    불러 온다고 생각해보자.

    AMD, CommonJS 모두 비동기 통신을 통해 파일을 동적으로
    불러오는 경우 성능의 이슈가 있기 때문에
    보통 프로덕션 서버로 배포 할 때 번들링(Bundling)작업을 진행하게
    된다.

    AMD는 define 함수와 require 함수를 통해 모듈 정의와 로딩을 진행하는데
    이 두가지 함수 모두 브라우저에서 인식 할 수 있는 함수가 아니다.
    따라서 우리는 require.js 스크립트를 추가적으로 불러와
    브라우저에서도 모듈 정의와 로딩이 동작하도록 한다.
    하지만 라이브러리에서 require.js 파일을 의존하여
    같이 빌트-인 하기에는 require.js 소스코드 용량이 크므로
    RequireJS측에서는 미니마이즈 버젼인 Almond(아몬드)를 제공한다.

    여러가지 유명 자바스크립트 라이브러리를 살펴봐도
    대부분 아몬드를 빌트인 하여 제공하고 있다.

CommonJS

    Node.js 진영에서는 CommonJS를 기본으로 사용하고 있다.
    당연하게도 Node.js에서 모듈을 불러오는 기본 스타일이
    CommonJS이기 때문에 프론트앤드 라이브러리일지라도
    Node.js 코드를 통해 유닛 테스팅을 하는 경우
    혹은 moment(시계, 시간 관련 라이브러리), 
    underscore(함수관련 라이브러리)처럼 Node.js에서도 사용
    가능해야 하는 라이브러리 일 경우 CommonJS모듈 형태도
    제공해야 한다. (프론트 단에서 제공해야함)

번들링

    쉽게 설명하자면 여러분의 모듈들을 하나의 단일 파일로
    취합하는 과정이다.
    앞서 언급된 모듈 타입(AMD,CommonJS,ES2015,ES6 etc)을 분석하고
    거기서 불러오는 파일을 파악하여 하나로 모아주는
    번들러(bundler), 묶음 역할을 한다.

    많이 사용하는 번들러의 종류는 웹팩, rollup.js Jspm Browserify
    이 있는데 우리는 Webpack을 사용하도록 하자. (정신건강에 좋음)


기타 - JavaScript IIFE 이해하기 (즉시 호출 함수 표현식?)

    IIFE(Immediately Invoked Function Expressions)은
    즉시 호출 함수 표현식의 줄임말입니다.

    전역 영역(Global Scope)를 오염시키지 않기 위해서 사용됩니다.

        주된 이유는 변수를 전역(global scope)로 선언하는 것을
        피하기 위해서 입니다. 많은 JavaScript 라이브러리와 전문가들이
        이 기법을 사용합니다. 지역 변수를 익명 함수로 위치시켜
        외부와의 충돌을 방지할 수 있습니다.
    
    즉 주요 이유는 전역 함수와 지역 함수 구분을 위한 
    클로저 정의를 위해 사용하는 것이다.

        
용어

    - Full : 컴파일러와 런타임을 포함.

    - Compiler : 템플릿 문자열을 JavaScript 렌더링 함수로 컴파일
                 하는 코드입니다.

    - Runtime : Vue 인스턴스 생성, 가상 DOM 렌더링 및 패치 등을
                담당하는 코드. 기본적으로 모든 컴파일러를 제외한 것.

    - UMD : UMD 빌드는 <script> 태그를 통해 브라우저에서 직접 사용할
            수 있다.  https://unpkg.com/vue의 Unpkg CDN의 기본 파일은 
            Runtime + Compiler UMD 빌드 (vue.js)입니다.

    -CommonJS : CommonJS 빌드는 browserify 또는 Webpack 1 과 같은
                이전 번들과 함께 사용하기 위한 것입니다.
                이러한 번들(pkg.main)의 기본 파일은 런타임 전용
                CommonJS 빌드(vue.runtime.common.js)입니다.
    
    -Es module : ES 모듈 빌드는 webpack2 또는 rollup 과 같은 최신 번들
                 과 함께 사용하기 위한 것입니다. 이러한 번들(pkg.module)
                 의 기본 파일은 런타임 전용 ES모듈 빌드(vue.runtime.esm.js)
                 입니다.
    
Runtime + Compiler vs. Runtime-only

    템플릿을 즉석에서 컴파일 해야하는 경우(예 : 문자열을 template 옵션에
    전달하거나 템플릿으로 in-DOM HTML을 사용하여 요소에 마운트하는 경우)
    컴파일러가 필요하므로 전체 빌드가 필요합니다.

    // 아래 내용은 컴파일러가 필요합니다
    new Vue({
        template: '<div>{{ hi }}</div>'
    })

    // 아래는 필요하지 않습니다
    new Vue({
        render (h) {
        return h('div', this.hi)
        }
    })

    vue-loader 또는 vueify를 사용할 때 *.vue 파일의 템플릿은 빌드시 
    JavaScript로 미리 컴파일됩니다. 최종 번들에 컴파일러가 실제로 
    필요하지 않으므로 런타임 전용 빌드를 사용할 수 있습니다.
    런타임 전용 빌드는 전체 빌드보다 약 30% 정도 작아서 언제든지 
    사용할 수 있습니다. 하지만 전체 빌드를 사용하려면 번들러에서 
    별칭을 구성해야 합니다.

Webpack

    module.exports = {
        // ...
        resolve: {
            alias: {
                'vue$': 'vue/dist/vue.esm.js' 
                // 'vue/dist/vue.common.js'  webpack 1용 입니다
            }
        }
    }


CSP 환경

    Google 크롬 앱과 같은 일부 환경에서는 CSP(컨텐츠 보안 정책)를
    적용하여 표현식을 평가하는 데 new Function() 을 사용할 수 없습니다.
    전체 빌드는 이 기능을 사용하여 템플릿을 컴파일하므로 이러한 환경에서는
    사용할 수 없습니다.

    반면 런타임 전용 빌드는 CSP와 완벽하게 호환됩니다.
    Webpack + vue-loader 또는 Browserify + vueify 로 런타임 전용
    빌드를 사용하는 경우 템플릿은 CSP 환경에서 완벽하게 작동하는 render
    함수로 미리 컴파일됩니다.

개발용 빌드

    중요합니다 : Github의 /dist 폴더에 있는 빌드된 파일은 릴리즈 중에만
                체크인 됩니다.(dist는 distribute, 배포라는 뜻이다.
                배포되는 파일이 들어있는 디렉토리라고 이해하면 된다.)
                Github의 최신 코드에서 Vue를 사용하려면 직접 빌드해야
                합니다.

                git clone https://github.com/vuejs/vue.git node_modules/vue
                cd node_modules/vue
                npm install
                npm run build

Bower

    Bower는 웹 프론트엔드 개발에 필요한 각종 라이브러리들을 관리할 수 있는
    npm, maven, gem과 같은 패키지 매니저입니다.

    (웹 프론트엔드에서 자주 사용하는 jQuery, Bootstrap과 같은 라이브러리들을
    간편하게 관리, 설치할 수 있다.)

    Bower에서는 UMD 빌드만 사용 가능합니다.

AMD 모듈 로더

    모든 UMD빌드는 AMD 모듈로 직접 사용할 수 있습니다.

배포

    자바스크립트 프론트앤드 환경에서는 제공하는 라이브러리를
    어떤식으로 호출 할지 모른다.

    - require([“], function(module) {})로 사용 할 수도 있고. (AMD)

    - var module = require(”)로 사용 할 수도 있다. (CommonJS)

    - 심지어 import { module } from “; 형태로 사용 할 수도 있다. (ES6)

    우리는 이런 모듈 방식을 모두 제공하는 팩토리 형태를 만들어야 한다.

    심지어 이 팩토리 표현에 대해서는 마땅한 표준도 없다.

    표준은 아니지만 UMD라는 친구가 있는데
    Universal Module Definition의 약자이다.
    여기서 제공하는 템플릿이 그래도 많이 사용되고 있는 듯 보인다.

mocking이란?

    주로 단위 테스트에 사용된다.
    실제 개체의 동작을 시뮬레이트하는 모의(mock)사용.
    실제 객체의 동작을 시뮬레이션하는 객체를 만드는 것입니다.

    * Node.js 환경에서는 window, document가 존재하지 않기 때문에
      window와 document를 jsdom을 통해 Mocking 하고있다.


결론

    결론적으로 아직 자바스크립트의 모듈링 표준은 걸음마 단계이다.
    아직 ECMA 6가 모든 브라우저에서 채택되지 않았기 때문에
    과도기적인 면모를 보인다.

    ECMA 6가 AMD와 CommonJS 스타일을 사용하지 않기 때문에 나중에는 
    AMD와 CommonJS 모두가 버려지는 아름다운 현상이 일어날 수도 있다.
    (2017년 3월 글이므로 ES6을 따라가자.)

출처 : https://blog.pigno.se/post/157992405313/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88-%EC%A0%9C%EA%B3%B5%EC%9D%84-%EC%9C%84%ED%95%9C-amd-commonjs-%EA%B7%B8%EB%A6%AC%EA%B3%A0-requirejs-%EC%86%8C%EA%B0%9C

-----------------------------------------------------------------

Vue.js를 시험해 볼 수 있는 가장 쉬운 방법은 
JSFiddle Hello World 예제를 사용하는 것입니다. 

https://jsfiddle.net/chrisvfritz/50wL7mdz/


(여기까지 공부했다. https://kr.vuejs.org/v2/guide/index.html)

-----------------------------------------------------

CDN(콘텐츠 전송 네트워크 - 트래픽 과부하 줄이는 전송 방식) 추가시 형식



<script src="https://unpkg.com/vue@2.5.16/dist/vue.js"></script>


<script>

    var app = new Vue({

        el: ,

        data: {

            

        },

        computed:  {



        },

        methods: {

        }
    });

</script>




----------------------------------------------------

자바스크립트 메소드

map은 콜백 함수의 리턴을 모아서 새로운 배열을 만드는 것이 목적입니다.

filter 메소드는 이름 그대로 요소들을 걸러내는 것이 목적입니다.



자바스크립트 메세지 뒤집기 : message.split('').reverse().join('');

    메시지라는 변수를 any character 로 각각 쪼갠 배열을 만들어서
    그 배열 순서를 뒤집고 다시 배열을 string으로 합친다.


뷰 문법

v-bind:data = 축약형인 :data

v-on:click = 축약형인 @click 

v-text="" 태그의 텍스트 노드에 ""값을 넣어줌

v-if = true일때 v-text 출력 / false면 출력 x


v-for = " 풀어줄 연관배열의 단수형이름 in data안의 연관배열(복수형)

        예 : tasks 라는 연관배열을 task라는 단수형으로 풀어준다. ( = foreach )

            <li v-for="task in tasks"></li>

            li태그의 속성에 추가로 v-text="task.description" 을 써주면 각 task의 description        
            속성을 랜더링해준다.

            li태그의 속성에 추가로 v-if="task.completed" 써주면
            
            completed속성의 값이 true인 것만 랜더링한다.

            *뷰의 computed는 리액티브적으로 작동하므로 데이터의 tasks에서
            한 인덱스의 completed속성의 값을 false를 true 로 바꿔줘도 화면에 반영되어 렌더링된다.


computed Property?

    뷰에서 미리 속성을 계산해놓고 필요할 때 렌더링하자.
    뷰 인스턴스에서 computed 속성을 만들어서 그 안에
    메소드를 미리 만들어 두면 된다.

ES6 에 기반한 함수 짜는법 (ES5와 비교)

    ES5 

        tasks.filter(function (task) {
            return ! task.completed;
        })

    ES6

        tasks.filter(task => ! task.completed);


캐쉬에 남아있는 경우? 새로고침해야 바뀌는 경우. -> Immediately return 방식

캐쉬에 남아있던말던 바로 반영되는 경우 -> Reactive 방식

* 뷰를 이용하면 얼마나 다이나믹하고(동적이고) 쉬운지 알 수 있다!

-------------------------------------

components

    1.우선 main.js 를 만들자.

    2. Vue.component('task', {

        template:'<li>foobar</li>

        }) 를 입력하자.

    어디서든 쓸 수 있는 글로벌 뷰 컴포넌트가 생성되었다.


    3. new Vue({

        el:'#root'

        }

        도 입력해주자.

    
    4. index.html 에서 id가 root 인 div 태그를 만들어놨었다고 가정하고
        그 안에 <task></task> 를 써보자.
        설정해둔 글로벌 뷰 컴포넌트가 나타나는 것을 확인할 수 있다.
    

* Vue.component('task', {

        template:'<li><slot></slot></li>

        })

        으로 바꿔주면 슬롯 부분이 HTML에서 태그 안에
        적는 텍스트 부분임을 의미한다.

        즉 뷰 컴포넌트에 슬롯을 추가한 상태에서 index.html에 
        <task>텍스트</task> 쓰면 화면상에는 <li>텍스트</li>를 
        출력한다는 것.

뷰 컴포넌트를 사용하면 이름을 줄 수 있고
탬플릿을 줄 수 있고 data도 줄 수 있음.

* 컴포넌트는 싱글 인스턴스와 연결되어 있지 않으므로
    데이터를 함수로 해서 오브젝트를 return 해주어야 한다.

----------------------------------------------------

뷰 컴포넌트의 기본 구조 예시

    HTML 
    
        <task-list></task-list>


    main.js

        Vue.component('task-list', {

            template: '
            
                <div>
                
                    <task v-for="task in tasks'>{{ task.task }}</tesk>
                    
                </div>
                
            ',

            data() {

                return {

                    tasks [

                        { task: 'Go to the store', complete: true },

                        { task: 'Go to the email', complete: false },

                        { task: 'Go to the farm', complete: true },

                        { task: 'Go to work', complete: false }

                    ]

                };

            }

        });


        Vue.componet('task', {
            template '<li><slot></slot></li>'
        });

        new Vue((

            el: '#root'

        ));



-----------------------------------------------------

선언적 렌더링

 Vue.js의 핵심은 간단한 탬플릿 구문을 사용해 선언적으로 DOM에 데이터를 렌더링하는 것입니다.


    <div id="app">
        {{ message }}
    </div>

    var app = new Vue({
        el: '#app',
        data: {
            message: '안녕하세요 Vue!'
        } 
    })

-----------------------------------------------------

Vue는 입력과 앱 상태를 양방향으로 바인딩하는 v-model 디렉티브를 제공합니다.

--------------------------------------------------------


사용자 입력 핸들링

    사용자가 앱과 상호 작용할 수 있게 하기 위해 우리는 v-on 디렉티브를 사용하여 Vue 인스턴스에 메소드를 호출하는 이벤트 리스너를 첨부 할 수 있습니다 :

    <div id="app-5">
        <p>{{ message }}</p>
    <button v-on:click="reverseMessage">메시지 뒤집기</button>
    </div>

    var app5 = new Vue({
        el: '#app-5',
        data: {
        message: '안녕하세요! Vue.js!'
    },

    methods: {
            reverseMessage: function () {
                this.message = this.message.split('').reverse().join('')
            }
        }
    })

------------------------------------------------------

컴포넌트를 사용한 작성방법

Vue에서, 컴포넌트는 본질적으로 미리 정의된 옵션을 가진 Vue 인스턴스 입니다. Vue에서 컴포넌트를 등록하는 방법은 간단합니다.

    // todo-item 이름을 가진 컴포넌트를 정의합니다
    Vue.component('todo-item', {
     template: '<li>할일 항목 하나입니다.</li>'
    })

    이제 다른 컴포넌트의 템플릿에서 이 컴포넌트를 사용할 수 있습니다.

    <ol>
     <!-- todo-item 컴포넌트의 인스턴스 만들기 -->
     <todo-item></todo-item>
    </ol>

-------------------------------------------------------

* 컴포넌트를 사용하여 부모 영역의 데이터를 자식 컴포넌트에 집어넣을 수 있다.

    대규모 응용 프로그램에서는 개발 과정을 관리할 수 있는 수준 하에 두기 위해 전체 앱을 컴포넌트로 나누는 것이 필수적입니다.

    자식 앱인 컴포넌트를 이용하여 부모 앱인 뷰 인스턴스에 영향을 주지 않으면서 개발이 가능합니다.


* 컴포넌트를 사용한 앱의 모습이 어떻게 구성될지에 대한 (상상의) 예를 제시하겠습니다.

<div id="app">
  <app-nav></app-nav>
  <app-view>
    <app-sidebar></app-sidebar>
    <app-content></app-content>
  </app-view>
</div>

즉 Vue.js를 이용하여 프론트앤드 단에서도 부품, 모듈화를 시켜서 작성이 가능하다는 것.

---------------------------------------------------------

* 모든 Vue 컴포넌트는 본질적으로 Vue 인스턴스로부터 확장된 것임을 알아야 합니다.

    Root instance 를 통해 확장된 컴포넌트로 구성되어 있다.

    아래는 뷰 앱 구조 예시이다.
    
    ex) Root Instance ( 루트 뷰 인스턴스. 컴포넌트 입장에서는 부모이다. )
        └─ TodoList ( 아래부터는 확장된 뷰 루트 인스턴스의 자식 컴포넌트들을 의미한다. )
            ├─ TodoItem
            │  ├─ DeleteTodoButton
            │  └─ EditTodoButton
            └─ TodoListFooter
                ├─ ClearTodosButton
                └─ TodoListStatistics        

---------------------------------------------------------

Proxy, 프록시 란?

    Proxy는 일반적으로 대리자/대리인을 의미하며 말 그대로 작업을 대신 수행하거나 중개해주는 역할을 하는 객체를 의미합니다.

    기존 소스를 수정하지 않고 객체의 행동을 다양한 방식으로 제어할 수 있기 때문에, Proxy 패턴은 현대 프레임워크에서 매우 중요한 역할을 담당합니다.

---------------------------------------------------------